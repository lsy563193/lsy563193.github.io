<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林少岳的博客</title>
  
  <subtitle>学而不思则罔 思而不学则殆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lsy563193.github.io/"/>
  <updated>2018-12-13T11:04:14.510Z</updated>
  <id>http://lsy563193.github.io/</id>
  
  <author>
    <name>ShaoYue Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cartographer论文翻译 二维构图的高效稀疏位姿调整</title>
    <link href="http://lsy563193.github.io/slam-EfficientSPAFor2DMapping/"/>
    <id>http://lsy563193.github.io/slam-EfficientSPAFor2DMapping/</id>
    <published>2018-11-27T03:03:04.000Z</published>
    <updated>2018-12-13T11:04:14.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>位姿图已成为解决同时定位和构图（SLAM）问题的流行表示。<br>位姿图是一组机器人位姿，通过观察附近位姿共有的特征获得的非线性约束连接。<br>优化大型位姿图一直是移动机器人的瓶颈，因为直接非线性优化的计算时间可以随着图的大小而指数增长。<br>在本文中，我们提出了一种构造和求解线性子问题的有效方法，这是这些直接方法的瓶颈。<br>我们将我们称为稀疏位姿调整（SPA）的方法与竞争间接方法进行比较，并表明它在收敛速度和准确性方面优于它们。<br>我们在大量室内真实世界地图和非常大的模拟数据集上展示了它的有效性。<br>C++中的开源实现和数据集是公开可用的。<br><a id="more"></a></p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>机器人构图的最新文献显示出对基于图的SLAM方法的兴趣日益增加。<br>在最一般的形式中，图形具有表示机器人位姿和世界特征的节点，测量将它们连接为约束。<br>所有方法的目标是共同优化节点的位姿，以便最小化约束引入的误差。<br>该问题的一个经典变体来自计算机视觉，并表示为束调整[25]，其通常用Levenberg-Marquardt（LM）非线性优化器的专用变体解决。<br>在SLAM文献中，Lu-Milios [18]，GraphSLAM [24]和√SAM[4]都是这种技术的变种。 </p><p>由于特征往往超过机器人位姿，<br>通过将特征观察转换为机器人位姿之间的直接约束，可以创建更紧凑的系统，<br>要么通过边缘化[1,24,4]，要么通过直接匹配 - 例如，<br>在两个机器人位姿之间匹配激光扫描产生两者的相对位姿估计。<br>在典型的机器人地图应用中，位姿约束系统表现出稀疏的连接结构， (所以SPA是通过位姿构造)<br>因为传感器的范围通常限于机器人的附近。</p><p>有效地解决位姿图（即，找到节点的最佳位置）是这些方法的关键问题，尤其是在在线构图问题的背景下。<br>100m x 100m 办公空间的典型2D激光地图可能有数千个节点和更多约束（见图1）。<br>此外，向此构图添加循环闭包约束可能会影响系统中的几乎所有位姿。<br>o<br><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/f1.png" alt="image"></p><p>LM方法的核心在于解决大的稀疏线性问题。</p><p>在本文中，我们开发了一种从约束图有效地计算稀疏矩阵的方法，并使用直接稀疏线性方法来解决它。<br>与视觉文献中的稀疏束调整类似，我们将此方法称为稀疏位姿调整（SPA），因为它处理位姿-位姿约束的受限情况。<br>SBA/GraphSLAM优化器与解决线性子问题的有效方法的组合具有以下优点。</p><ul><li><p>它考虑约束中的协方差信息，从而得到更精确的解。</p></li><li><p>SPA是健壮的并且容忍初始化，对于增量处理和批处理来说，具有非常低的故障率（陷入局部最小值）。</p></li><li><p>收敛非常快，因为它只需要LM方法的几次迭代。</p></li><li><p>与EKF和信息滤波器不同，SPA是完全非线性的：在每次迭代中，它线性化当前位姿周围的所有约束。</p></li><li><p>SPA在批处理和增量模式下都是有效的</p></li></ul><p>我们在实验结果部分记录了该方法的这些和其他特征，其中我们还将此方法与其他LM和非LM的最新优化器进行比较。</p><p>SPA效率的好处之一是，构图系统可以连续优化其图，提供所有节点的最佳全局估计，而计算开销非常小。<br>解决图1所示的大型地图的优化问题只需要距离里程计提供的初始配置150ms。</p><p>在增量模式下，在添加每个节点之后优化图，对于任何节点添加，它需要小于15ms。</p><p>尽管SPA可以用3D位姿参数化，但是本文将其局限于二维构图，这是一个具有多种竞争优化技术的成熟领域。<br>我们的意图是表明一个基于二维位姿的构图系统可以在线使用SPA作为其优化引擎，甚至在大规模环境和具有大环路闭合，而不诉诸子构图或复杂的划分方案。</p><h2 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h2><p>18 1997 — 提出graph slam,无优化，慢</p><p>13 2001 — 松弛法定位机器人<br>06 2002 — 高斯-塞德尔松弛法最小化约束网络中的误差。<br>09 2005 — 多层松弛法</p><p>21 2006 — 优化位姿图 提出随机梯度下降法<br>10 2009 — 基于树的参数化 提高梯度下降法收敛速度</p><p>02 1995 — 最直观的方法:非线性最小二乘优化(ML pass) 一种有前途的技术是预条件共轭梯度PCG<br>15 2004 — 大规模制图 使用了PCG作为解析器<br>20 2004 — 大规模3d制图 使用了PCG作为解析器<br>05 1994 — 稀疏矩阵库<br>03 2006 — 直接线性求解器<br>04 2005 — 使用稀疏的直接线性求解器[3]实现束调整<br>14 2007 — $\sqrt{SAM}$的变体，称为iSAM</p><p>07 2006 — 用信息矩阵形式递增地求解图的滤波技术:延迟稀疏信息滤波器（DSIF）<br>08 2006 — 通过树表示来捕获系统的稀疏结构</p><p>00 2010 — 直接稀疏Cholesky分解求解线性系统的二维位姿图优化方法</p><p>Lu和Milios[18]提出了基于图的SLAM的具有开创性的工作，其中他们通过ICP扫描匹配来确定扫描之间的成对测量，然后通过迭代线性化来优化该图。<br>那时，SLAM社区还没有有效的优化算法，基于图的方法被认为太耗时。<br>尽管如此，基于图的SLAM的直观公式吸引了许多研究者，并做出了有价值的贡献。</p><p>自从Lu和Milios论文发表以来，人们提出了许多图优化的方法。<br>霍华德等人[13]应用松弛法定位机器人并建立地图。<br>杜克特等人[6]提出了利用高斯-塞德尔松弛来最小化约束网络中的误差。<br>为了克服松弛法固有的收敛速度慢，Frase等人[9]提出了Gauss-Seidel松弛的一种变型，称为多层松弛法(MLR)。<br>它适用于不同分辨率的松弛。<br>据报道，MLR在2D环境中提供非常好的结果，尤其是在初始猜测的误差有限的情况下。</p><p>奥尔森[21]等人提出了随机梯度下降法来优化位姿图。<br>这种方法的优点是易于实现，并且对错误的初始猜测异常健壮。<br>后来，格里塞蒂等[10]通过应用显著提高收敛速度的基于树的参数化来扩展这种方法。<br>这些方法的主要问题是，它们假设图中的误差或多或少是均匀的，因此它们很难应用于某些约束未被指定的图。</p><p>优化图的最直观的方法可能是通过非线性最小二乘优化，如LM。<br>最小二乘法需要重复求解通过线性化图的原始似然函数而获得的大型线性系统。<br>这种线性系统通常非常大；因此，第一种基于图的方法是耗时的，因为它们没有利用其自然的稀疏性。<br>一种有前途的技术是预条件共轭梯度（PCG）[2]，后来被Konolige[15]和Montemerlo和Srun[20]用作大型稀疏位姿约束系统的有效求解器； 预条件通常是不完全Cholesky分解。<br>PCG是一种迭代方法，一般需要n次迭代才能收敛，其中n是图中变量的数目。<br>我们从Sparselib++和IML++[5]中实现了PCG的稀疏矩阵版本，并将该实现用于比较实验。</p><p>最近，Dellaert和他的同事使用束调整，他们使用稀疏的直接线性求解器[3]实现束调整；他们称他们的系统$\sqrt{SAM}$[4]。<br>我们的方法与SAM类似；主要在工程上不同，我们是通过使用有序数据结构高效地构造线性子问题。<br>我们还使用LM代替标准的非线性最小二乘法，从而提高了鲁棒性。<br>最后，我们介绍了增量情况下的一种“连续LM”方法，以及一种更稳健的批处理问题的初始化方法。</p><p>凯斯等人。[14]引入了$\sqrt{SAM}$的变体，称为iSAM，其执行与非线性最小二乘问题相关联的线性矩阵的增量更新。<br>只偶尔执行重线性化和变量排序，从而提高计算效率。<br>在我们的方法中，重新线性化和矩阵构造是非常有效的，因此这些方法变得不太必要。<br>目前，我们没有iSAM或_SAM的实现，无法针对性能进行测试。</p><p>松弛法或最小二乘法通过迭代地细化初始猜测来进行。<br>相反，基于随机梯度下降的方法对初始猜测更稳健。<br>在SLAM文献中，这种初始猜测的重要性经常被低估。<br>初始猜测越好，算法找到正确解决方案的可能性就越大。<br>在本文中，我们讨论了这一点，并评估了三种不同的策略来计算初始猜测。</p><p>与全非线性优化相比，一些研究人员探索了使用信息矩阵形式递增地求解图的滤波技术。<br>第一种这样的方法是由EuStruts等人提出的。<br>并称之为延迟稀疏信息滤波器（DSIF）〔7〕。<br>这种技术可能是非常有效的，因为它仅向系统信息矩阵添加少量的常数元素，甚至对于循环闭合也是如此。<br>然而，恢复所有节点的全局位姿需要求解一个大型的稀疏线性系统；有更快的方法来获得近似的最近位姿。</p><p>Frese提出了TreeMap [8]算法，该算法通过树表示来捕获系统的稀疏结构。<br>树中的每个叶子都是一个局部地图，估计的一致性是通过树发送更新到局部地图来实现的。<br>在理想条件下，此方法可以在O（n log n）时间内更新整个地图，其中n是地图中元素的数量。<br>但是，如果地图具有许多局部连接，则局部地图的大小可能非常大，并且它们的更新（被视为基本操作）变得计算成本昂贵，如本文其余部分所示。</p><p>综上所述，本文提出了一种利用直接稀疏Cholesky分解求解线性系统的二维位姿图优化方法。<br>线性系统的计算采用内存高效的方式，使缓存遗漏最小化，从而显著提高了性能。<br>我们将我们的方法在精度和速度上与可用的现有LM和非LM方法进行比较，并且表明SPA优于它们。<br>开源实现在C++和Matlab/OcthVE中都是可用的。<br>用于求解稀疏系统的有效直接（非迭代）算法已经变得可用[3]，从而恢复了一系列用于优化过去被丢弃的图的方法。</p><p>在本文中，</p><h2 id="III-SYSTEM-FORMULATION"><a href="#III-SYSTEM-FORMULATION" class="headerlink" title="III. SYSTEM FORMULATION"></a>III. SYSTEM FORMULATION</h2><p>解决SLAM问题的流行方法是所谓的“基于图”或“基于网络”方法。<br>这个想法是通过图来表示机器人测量的历史。<br>图中的每个节点表示传感器测量或局部地图，并且用测量所处的位置对其进行标记。<br>两个节点之间的边缘编码由于连接测量的对齐而产生的空间信息，并且可以被视为两个节点之间的空间约束。</p><p>在基于图的SLAM环境中，通常考虑两个不同的问题。<br>第一种是基于传感器数据识别约束。<br>由于环境中的潜在模糊或对称性，这种所谓的数据关联问题通常很难解决。<br>这个问题的解决方案通常被称为SLAM前端，它直接处理传感器数据。<br>第二个问题是修正机器人的位姿，以获得给定约束环境的一致构图。<br>这种方法的这一部分通常被称为优化器或SLAM后端。<br>它的任务是寻找使约束中编码的测量的可能性最大化的节点的配置。<br>对这个问题的另一种观点是由物理学中的弹性模型给出的。<br>在这种观点中，节点被视为质量，而约束则被视为与质量相连的弹簧。<br>弹簧和质量的最小能量配置描述了构图问题的解决方案。</p><p>在其操作期间，基于图的SLAM系统交错前端和后端的执行，如图2所示。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/f2.png" alt="image"></p><p>这是必需的，因为前端需要对部分优化的构图进行操作，以限制对潜在约束的搜索。<br>当前估计越精确，由前端生成的约束将越健壮，并且其操作也越快。<br>因此，从估计精度和执行时间方面衡量的优化算法的性能对整个构图系统有重要影响。</p><p>本文详细描述了一种高效紧凑的二维图优化方法。<br>我们的算法可以与处理不同类型传感器的任意前端耦合。<br>为了简洁的介绍，我们简短地描述了激光数据的前端。<br>然而，一般概念可以直接应用于不同的传感器。</p><h2 id="IV-SPARSE-POSE-ADJUSTMENT"><a href="#IV-SPARSE-POSE-ADJUSTMENT" class="headerlink" title="IV. SPARSE POSE ADJUSTMENT"></a>IV. SPARSE POSE ADJUSTMENT</h2><p>为了优化一组位姿和约束，我们使用众所周知的Levenberg-Marquardt(LM)方法作为框架，并且使用特定的实现使其对于二维地图构建中遇到的稀疏系统有效。<br>类似于计算机视觉的稀疏束调整（SPA），它是用于相机和特征的LM的类似高效实现，我们称之为稀疏位姿调整（SPA）。</p><h3 id="A-Error-Formulation"><a href="#A-Error-Formulation" class="headerlink" title="A. Error Formulation"></a>A. Error Formulation</h3><p>系统的变量是机器人的全局位姿集，通过平移和角度参数化:$c_i=[t_i , θ_i ] = [x_i , y_i , θ_i]^⊤$<br>约束是来自另一个（$c_i$）位置的一个节点$c_j$的测量。在$c_i$的帧中，$c_i$和$c_j$之间的测量偏移是$\overline{z}_{ij}$，具有精度矩阵Λij（协方差的倒数）。<br>对于$c_i$和$c_j$的任何实际位姿，它们的偏移可以计算为</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l1.png" alt="image"></p><p>这里$R_i$是$θ_i$的2x2旋转矩阵。 $h(c_i , c_j )$称为测量方程。与约束相关的误差函数和总误差是</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l2.png" alt="image"></p><p>注意，$h(c_i，c_j)$中的角度参数不是唯一的，因为加上或减去2π会产生相同的结果。当角度差发生时，它们总是标准化为间隔（-π，π）。</p><h3 id="B-Linear-System"><a href="#B-Linear-System" class="headerlink" title="B. Linear System"></a>B. Linear System</h3><p>通过最小化等式2中的总误差来找到$c$的最佳位置。解决该问题的标准方法是Levenberg-Marquardt（LM），围绕c的当前值迭代线性化解。通过将变量c堆叠到向量x中来形成线性系统，并且误差函数被形成为向量e。然后我们定义：</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l3.png" alt="image"></p><p>LM系统是:</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l4.png" alt="image"></p><p>这里λ是一个小的正乘数，它在梯度下降和牛顿-欧拉方法之间转换。梯度下降更稳健，不太可能陷入局部最小值，但收敛缓慢;牛顿-欧拉的行为相反。通过为每个测量$h（c_i，c_j）$添加四个分量来形成矩阵H.</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l5.png" alt="image"></p><p>这里我们略微滥用了J的符号，其中$J_i$是关于变量$c_i$的$e_{ij}$的雅可比行列式。这些组件都是3x3块。通过为每个约束添加3x1块$J_{c_i}Λ_{ij}e_{ij}$和$J_{c_j}Λ_{ij}e_{ij}$形成右侧。求解线性方程得到增量Δx即可被添加回x的当前值，如下所示：</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l6.png" alt="image"></p><h3 id="C-Error-Jacobians"><a href="#C-Error-Jacobians" class="headerlink" title="C. Error Jacobians"></a>C. Error Jacobians</h3><p>测量函数的雅可比行列式在正则方程式（4）中出现，我们在这里列出它们。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l7.png" alt="image"></p><h3 id="D-Sparsity-稀疏性"><a href="#D-Sparsity-稀疏性" class="headerlink" title="D.  Sparsity 稀疏性"></a>D.  Sparsity 稀疏性</h3><p>我们感兴趣的是大型系统，其中||c||的数量可以是10k或更多（我们能够找到的最大真实世界室内数据集是大约3k位姿，但我们可以生成任何顺序的合成数据集）。系统变量的数量是3||c||，而H矩阵是||c ||^2，或者超过$10^8$个元素。。操纵这样大的矩阵是昂贵的。幸运的是，对于典型的场景，约束的数量仅与位姿的数量成线性关系，因此它非常稀疏。我们可以利用稀疏性来更有效地解决线性问题。</p><p>为了以稀疏格式求解（4），我们使用CSparsepackage [3]。该软件包具有针对稀疏线性系统的高度优化的Choleskydecomposition求解器。它采用了几种高效分解策略，包括逻辑排序和近似最小度（AMD）算法，以便在变量很大时对变量进行重新排序。</p><p>通常，分解的复杂性将是变量数量的O（n3）。对于稀疏矩阵，复杂性将取决于Cholesky因子的密度，而Cholesky因子的密度又取决于H的结构及其变量的顺序。Mahon等[19]分析了Clesles分解的行为作为SLAM系统中闭环的函数。如果循环闭合的数量是恒定的，那么Cholesky因子密度是O（n），并且分解是O（n）。如果循环闭包的数量随着变量的数量线性增长，则Cholesky因子密度增长为O（n2），分解为O（n3）。</p><h3 id="E-Compressed-Column-Storage-压缩列存储"><a href="#E-Compressed-Column-Storage-压缩列存储" class="headerlink" title="E.  Compressed Column Storage 压缩列存储"></a>E.  Compressed Column Storage 压缩列存储</h3><p>LM算法的每次迭代都有三个步骤：建立线性系统、分解H和通过回代寻找$\Delta x$。建立系统的约束数量是线性的（因此基于多数图的SLAM系统的变量数量也是线性的）。在许多情况下，它可能成为线性求解器中成本较高的部分。这里我们概括了根据方程（5）产生的约束条件建立H的稀疏矩阵形式的一种有效方法。下图显示了基本思想。</p><p>CSparse使用压缩列存储（CCS）格式的forsparse矩阵。下图显示了基本概念。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/l8.png" alt="image"></p><p>数组中的每个非零条目都放在val向量中。条目首先按列排序，然后按行排序。col_ptr每列有一个条目，加上最后一个条目，即非零总数（nnz）。列的col_ptr条目指向row_ind和val变量中列的开头。最后，row_ind给出了列中每个条目的行索引。</p><p>CCS格式具有存储效率，但难以逐步创建，因为对列的每个新的非零添加都会导致所有后续条目的移位。最有效的方法是按列顺序创建稀疏矩阵，这需要循环通过约束|| c ||次。相反，我们只修改一次约束，并将每个3x3块$J_i^TΛ_{ij}J_{i}$存储在一个与CCS格式平行的特殊的面向块的数据结构中。该算法在表I中给出。在该算法中，我们通过约束来将3×3块矩阵存储到C ++ std :: mapdata结构中，每列一个。构图在基于其键（行索引）的有序插入时是有效的。一旦创建了这个数据结构（步骤（2）），我们使用构图的有序特性来创建Hby的稀疏CCS格式，按照其键的顺序循环遍历每个构图，首先创建列和行索引，以及然后放入值。将列/行创建与值插入分开的原因是因为对于LM的任何迭代集合，前者只需要执行一次。</p><p>注意，只存储H的上三角形元素，因为CSparse中的Cholesky解算器仅查看该部分，并假设矩阵是对称的。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/t1.png" alt="image"></p><p>F.可持续的LM系统</p><p>LM系统算法详见表II。对于具有相关测量的一组节点c，它在LM算法中执行一步。运行单次迭代允许LM的增量操作，以便在迭代之间可以添加更多节点。该算法是可持续的，因为λ在迭代之间被保存，因此连续迭代可以基于它们的结果改变λ。这个想法是添加一些节点和测量不会对系统产生太大的影响，因此λ的值具有关于梯度下降状态与欧拉 - 牛顿方法的信息。当发生循环闭合时，系统可能无法找到一个好的最小值，并且λ将在接下来的几次迭代中上升以使系统沿着良好的路径前进。</p><p>有许多不同的调整λ的方法;我们选择一个简单的方法。系统以一个小的lambda开始， $10^4$ 。如果更新的系统具有比原始系统更低的误差，则λ减半。如果误差相同或更大，则λ加倍。这在增量优化的情况下非常有效。只要在添加节点时误差减小，λ就会减小，系统会停留在Newton-Euler区域。当添加链接导致无法校正的大失真时，λ可以上升并且系统返回到更稳健的梯度下降。</p><h2 id="V-SCAN-MATCHING-扫描匹配"><a href="#V-SCAN-MATCHING-扫描匹配" class="headerlink" title="V.  SCAN MATCHING 扫描匹配"></a>V.  SCAN MATCHING 扫描匹配</h2><p>SPA需要通过激光扫描（或其他传感器）的匹配进行精确（逆协方差）估计。有几种扫描匹配算法可以提供这种算法，例如，Gutmannet等[11]使用点匹配参考扫描中提取的线，并返回高斯误差估计。最近，由Olson [22]扩展的Konolige和Chou [17]的相关方法提供了一种在给定范围内找到全局最佳匹配的有效方法，同时返回准确的协方差。该方法允许单个扫描或一组对齐扫描与另一个单个扫描或一组对齐扫描匹配。此方法在SRI的构图系统$Karto^1$中用于顺序扫描的局部匹配，以及[12]中的扫描集的循环闭包匹配。为了生成实验的真实数据集，我们在63个不同大小的存储机器人日志上运行Karto，使用其扫描匹配和优化器来构建构图并生成约束，包括循环闭包。保存图表并将其用作实验中所有方法的输入。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/t2.png" alt="image"></p><h2 id="VI-EXPERIMENT-实验"><a href="#VI-EXPERIMENT-实验" class="headerlink" title="VI.  EXPERIMENT 实验"></a>VI.  EXPERIMENT 实验</h2><p>在本节中，我们将展示实验，其中我们将SPA与63个真实世界数据集和大型模拟数据集上的最新方法进行比较。我们考虑了各种各样的方法，包括最先进的技术。</p><ul><li>信息过滤器：DSIF[7] </li><li>随机梯度下降：环面[ 10 ]</li><li>分解非线性系统：Treemap[8]</li><li>稀疏姿态调整：SPA，带有(a)稀疏直接Cholesky求解器和(b)迭代PCG[15]</li></ul><p>我们更新了PCG实现，以使用与SPA相同的“连续LM”方法；惟一的区别在于底层的线性求解器。先决条件是不完全Cholesky方法，共轭梯度以稀疏矩阵形式实现。我们还评估了一个稠密的Cholesky求解器，但是计算和内存需求都比其他方法大几个数量级。例如，对于具有1600个约束和800个节点的数据集，使用密集Cholesky求解器进行迭代需要2.1秒，而其他方法平均需要几毫秒。所有实验都在2.67Ghz运行的Intel Core i7-920上进行。</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/f3.png" alt="image"></p><p>在下文中，我们报告了在不同操作条件下方法的行为的累积分析；所有数据集的结果可在线查阅www.ros.org/./2010/spa。我们在批处理和在线两种模式下测试了各种方法。在批处理模式下，我们为算法提供全图，而在线模式下，每当向图中添加一个新节点时，我们都进行一定数量的迭代。在本节的其余部分中，我们首先讨论离线实验，然后介绍在线实验。通过对大规模仿真数据集上各种方法的分析，得出结论。</p><h3 id="A-精度测量"><a href="#A-精度测量" class="headerlink" title="A.精度测量"></a>A.精度测量</h3><p>对于这些室内数据集，没有基本事实。相反，姿态约束系统的优良性度量是约束的协方差加权平方误差，或称^2误差。如果扫描匹配器是准确的，那么较低的^2表示扫描对齐得更好。图3显示了在真实世界数据集上的这种效果。</p><h3 id="B-真实世界实验：离线优化。"><a href="#B-真实世界实验：离线优化。" class="headerlink" title="B.真实世界实验：离线优化。"></a>B.真实世界实验：离线优化。</h3><p>为了离线优化数据集，我们为每个优化器提供问题的完整描述。我们在比较DSIF和TreeMap时省略了它们，因为它们只增量地操作（DSIF相当于批处理模式下SPA的一次迭代）。由于离线优化的成功很大程度上取决于初始猜测，因此我们还研究了两种初始化策略，如下所述。</p><ul><li>里程计: 图中的节点用增量约束进行初始化。这是几乎所有的图优化算法所采用的标准方法。</li><li>生成树: 使用广度优先访问在图上构造生成树。树的根是图的第一个节点。节点的位置根据生成树的深度优先访问进行初始化。将子节点的位置设置为根据连接约束转换后的父节点的位置。在我们的实验中，这种方法给出了最好的结果。</li></ul><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/2d-spa/f4.png" alt="image"></p><p>对于每个数据集和每个优化器，我们计算上面描述的初始猜测。每个优化器都运行最少的迭代次数，或者直到满足终止条件为止。我们测量了收敛所需的时间和每种方法的2误差。图4总结了Odo.和Spanning-Tree初始化的结果。对于这些数据集，这两种类型的初始化在性能上没有实质性差异。</p><p>在误差图中，PCG和SPA收敛到几乎完全相同的解，因为唯一的区别是线性差异。求解器。它们都主导TORO，对于较大的图，TORO的误差是TORO的10倍以上。我们把此归因于TORO无法处理非球面协方差，以及它的非常慢的收敛特性。对于几乎所有的图，SPA所需的计算量几乎比PCG或TORO少一个数量级。</p><p>TORO被设计成对糟糕的初始化具有鲁棒性，并且为了测试这一点，我们还运行所有方法，所有节点都初始化为(0，0，0)。在这种情况下，SPA和PCG收敛到所有数据集的非全局最小值，而TORO能够重建正确的拓扑。</p><h3 id="C-真实世界实验：在线优化"><a href="#C-真实世界实验：在线优化" class="headerlink" title="C.真实世界实验：在线优化"></a>C.真实世界实验：在线优化</h3><p>对于在线比较，我们通过添加一个节点以及通过将新添加的节点连接到先前存在的图来递增地扩充图。我们在插入每个节点之后调用优化器，并且以这种方式在与SLAM前端一起执行时模拟它的行为。对于最大次数的迭代，或者直到误差不减小为止，进行优化。SPA/PCG的最大迭代次数是1；TreeMap为3；TORO为100。由于PCG迭代求解线性子问题，因此我们把其限制在50次迭代。选择这些阈值是为了在减少错误方面获得最佳性能。</p><p>在收敛性方面，SPA/PCG方法占主导地位。这对于DSIF的情况并不奇怪，DSIF是一种信息过滤器，因此在关闭大循环时会出现线性化误差。TORO具有与SPA最接近的性能，但每次迭代的收敛速度非常慢，这是梯度方法的特点；在收敛性方面，SPA/PCG方法占主导地位。这对于DSIF的情况并不奇怪，DSIF是一种信息过滤器，因此在关闭大循环时会出现线性化误差。TORO算法与SPA算法性能最接近，但每次迭代的收敛速度很慢，具有梯度法的特点；在收敛性方面，SPA/PCG算法是其他算法的主要特点。这对于DSIF的情况并不奇怪，DSIF是一种信息过滤器，因此在关闭大循环时会出现线性化误差。TORO具有与SPA最接近的性能，但每次迭代的收敛速度非常慢，这是梯度方法的特点；它也不处理非循环协方差，这限制了它实现最小2的能力。由于树图具有建立树结构进行优化的复杂策略，因此很难进行分析。对于这些数据集，它似乎有一个带有小叶子的大树（大型数据集循环）。通过固定线性化和删除连接，优化了树结构，使计算速度快，但收敛性差，2比SPA差近3个数量级。</p><p>所有的方法在约束图的大小上都是近似线性的，这意味着大循环闭包的数量增长缓慢。在所有数据集中，Treemap的性能最好，其次是SPA和DSIF。注意，SPA的行为是极其规则的：在任何数据集上与线性级数几乎没有偏差。此外，平均时间和最大时间是相同的：参见图8中的图表。最后，TORO和PCG每次迭代使用更多的时间，PCG大约是SPA的四倍。由于SPA的快速收敛性，我们只需每增加n个节点，就可以实现更低的计算量。我们强调这些图表是我们所能找到的最大的室内数据集，它们对SPA来说并不具有挑战性。</p><h3 id="D-合成数据集"><a href="#D-合成数据集" class="headerlink" title="D.合成数据集"></a>D.合成数据集</h3><p>为了估计算法的渐近行为，我们生成一个大的模拟数据集。机器人在网格上移动，网格的每个单元格都有5米的一边，我们每米创建一个节点。这个机器人的感知范围是1.5米。机器人的运动和测量都受到标准偏差为u=diag(0.01m,0.01m,0.5deg)的零均值高斯噪声的影响。每当机器人接近它访问过的位置时，我们就生成一个新的约束。模拟区域跨度超过500×500米，轨道总长100公里，重复观测频繁。全图如图6所示。这是一个极具挑战性的数据集，比任何真实世界的数据集都要糟糕。下面，我们报告所有我们比较的算法的批处理和在线执行的结果。</p><p>a)离线优化：每个批处理方法都使用前面部分描述的三个初始化来执行：里程计、生成树和零。结果如图7所示，是时间的函数。唯一能从零或里程表初始化优化图的方法是TORO；SPA/PCG在里程表或零开始时基本上不会收敛到全局最小值。SPA/PCG在生成树初始化后10秒左右全局收敛，在收敛点SPA明显更快（参见图7中的放大图）。TORO具有良好的初始收敛性，但由于梯度下降而具有长尾。</p><p>b)在线优化：我们增量地处理数据集，如第六-C节所述。在图8中，我们报告了每增加一个节点2误差和时间的演变。SPA和TreeMap都收敛到最小2（对于收敛图，参见图7）。然而，它们的计算行为非常不同：TreeMap每次迭代最多可以使用100秒，而SPA随着图的大小而缓慢增长。由于TreeMap在数据集中进行重访，因此树形图具有叶子非常大的小树，并且在每个叶子处执行LM优化，导致低误差和高计算量。其他方法具有与SPA等效的计算量，但不收敛。同样地，DSIF性能很差，并且不会收敛。TORO收敛，但是像往常一样难以清除小的误差。PCG的尖峰是由于它没有完全解决线性子问题，最终导致较高的整体误差。</p><h2 id="VII-结论"><a href="#VII-结论" class="headerlink" title="VII. 结论"></a>VII. 结论</h2><p>本文提出并实验验证了一个二维姿态图的稀疏姿态调整非线性优化系统。SPA依赖于有效的线性矩阵构造和稀疏的非迭代Cholesky分解来有效地表示和解决大型稀疏姿态图。我们所能找到的真实数据集中没有一个是具有挑战性的——即使在批处理模式下也是如此。最大构图需要次秒的时间才能完全优化。联机计算最坏在10ms/节点范围内；与EKF滤波器或其他计算性能差的方法不同，我们不需要将构图分割成子构图[23]来获得全局最小误差。</p><p>与现有方法相比，SPA更快，收敛更好。唯一的例外是在初始化较差的构图中，只有TORO的随机梯度技术才能收敛；但是通过应用生成树初始化，SPA甚至能比TORO更好地解决复杂的合成实例。当与扫描匹配前端结合时，SPA将支持在线勘探和地图构建。因为SPA是一种姿态图方法，所以它允许对地图进行增量添加和删除，便于终身构图[16]。</p><p>用于运行SPA的所有相关代码和我们实现的其他方法都可以作为开放源码以及数据集和仿真生成器（www.ros）在线获得。org/./2010/spa)随附的视频显示在一个大型的真实世界数据集上的在线和离线模式下的SPA。</p><h2 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h2><p>[1]  M.  Agrawal  and  K.  Konolige.  FrameSLAM:  From  bundle  adjustmentto  real-time  visual  mapping.IEEE  Transactions  on  Robotics,  24(5) October 2008.</p><p>[2]   F. F. Campos and J. S. Rollett. Analysis of preconditioners for conjugategradients  through  distribution  of  eigenvalues.Int.  J.  of  ComputerMathematics, 58(3):135–158, 1995.</p><p>[3]   T. A. Davis.Direct Methods for Sparse Linear Systems (Fundamentalsof  Algorithms  2).Society  for  Industrial  and  Applied  Mathematics,Philadelphia, PA, USA, 2006.</p><p>[4]   F.  Dellaert.    Square  Root  SAM.    InProc.  of  Robotics:  Science  and Systems (RSS), pages 177–184, Cambridge, MA, USA, 2005.</p><p>[5]   J. Dongarra, A. Lumsdaine, R. Pozo, and K. Remington. A sparse matrixlibrary  in  c++  for  high  performance  architecture   s.  InObject OrientedNumerics Conference, pages 214–218, 1994.</p><p>[6]   T. Duckett, S. Marsland, and J. Shapiro. Fast, on-line learning of globally consistent maps.Journal of Autonomous Robots, 12(3):287 – 300, 2002.</p><p>[7]   R. M. Eustice, H. Singh, and J. J. Leonard. Exactly sparsedelayed-statefilters for view-based SLAM.IEEE Trans. Robotics, 22(6), 2006.</p><p>[8]   U.  Frese.    Treemap:  Ano(logn)algorithm  for  indoor  simultaneouslocalization  and  mapping.Journal of Autonomous Robots,  21(2):103–122, 2006.</p><p>[9]   U. Frese, P. Larsson, and T. Duckett.  A multilevel relaxation algorithmfor  simultaneous  localisation  and  mapping.IEEE  Transactions  onRobotics, 21(2):1–12, 2005.</p><p>[10]  G. Grisetti, C. Stachniss, and W. Burgard. Non-linear constraint networkoptimization for efficient map learning.IEEE Transactions on IntelligentTransportation Systems, 10:428–439, 2009.  ISSN: 1524-9050.</p><p>[11]  J.-S. Gutmann, M. Fukuchi, and K. Sabe. Environment identification bycomparing maps of landmarks. InInternational Conference on Roboticsand Automation, 2003.</p><p>[12]  J.-S.  Gutmann  and  K.  Konolige.   Incremental  mapping  of  large  cyclicenvironments.  InProc. of the IEEE Int. Symposium on ComputationalIntelligence in Robotics and Automation (CIRA), pages 318–325, Mon-terey, CA, USA, 1999.</p><p>[13]  A.  Howard,  M.  Matari ́c,  and  G.  Sukhatme.    Relaxation  on  a  mesh:a  formalism  for  generalized  localization.    InProc.  of  the  IEEE/RSJInt. Conf. on Intelligent Robots and Systems (IROS), pages 1055–1060,2001.</p><p>[14]  M.  Kaess,  A.  Ranganathan,  and  F.  Dellaert.   iSAM:  Fast  incrementalsmoothing and mapping with efficient data association.  InInternationalConference on Robotics and Automation, Rome, 2007.</p><p>[15]  K. Konolige.  Large-scale map-making.  InProceedings of the NationalConference on AI (AAAI), 2004.</p><p>[16]  K.  Konolige  and  J.  Bowman.Towards  lifelong  visual  maps.InInternational  Conference  on  Intelligent  Robots  and  Systems,  pages1156–1163, 2009.</p><p>[17]  K.  Konolige  and  K.  Chou.   Markov  localization  using  correlation.   InProc. of the Int. Conf. on Artificial Intelligence (IJCAI), 1999.</p><p>[18]  F.  Lu  and  E.  Milios.    Globally  consistent  range  scan  alignment  for environment mapping. Journal of Autonomous Robots, 4:333–349, 1997.</p><p>[19]  I. Mahon, S. Williams, O. Pizarro, and M. Johnson-Roberson.  Efficientview-based  SLAM  using  visual  loop  closures.IEEE  Transactions  onRobotics, 24(5):1002–1014, October 2008.</p><p>[20]  M. Montemerlo and S. Thrun. Large-scale robotic 3-d mapping of urbanstructures.  InISER, 2004.</p><p>[21]  E. Olson, J. Leonard, and S. Teller.  Fast iterative optimization of posegraphs  with  poor  initial  estimates.  InProc. of the IEEE Int. Conf. onRobotics &amp; Automation (ICRA), pages 2262–2269, 2006.</p><p>[22]  E.  B.  Olson.    Real-time  correlative  scan  matching.    In International Conference on Robotics and Automation, pages 4387–4393, 2009.</p><p>[23]  L.  Paz,  J.  Tard ́os,  and  J.  Neira.   Divide  and  conquer:  EKF  SLAM  inO(n).IEEE Transactions on Robotics, 24(5), October 2008.</p><p>[24]  S.  Thrun  and  M.  Montemerlo. The  graph  SLAM  algorithm  with applications  to  large-scale  mapping  of  urban  structures.Int.  J.  Rob.Res., 25(5-6):403–429, 2006.</p><p>[25]  B. Triggs, P. F. McLauchlan, R. I. Hartley, and A. W. Fitzibbon. Bundle adjustment  -  a  modern  synthesis.   InVision  Algorithms:  Theory  and Practice, LNCS, pages 298–375. Springer Verlag, 2000.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;位姿图已成为解决同时定位和构图（SLAM）问题的流行表示。&lt;br&gt;位姿图是一组机器人位姿，通过观察附近位姿共有的特征获得的非线性约束连接。&lt;br&gt;优化大型位姿图一直是移动机器人的瓶颈，因为直接非线性优化的计算时间可以随着图的大小而指数增长。&lt;br&gt;在本文中，我们提出了一种构造和求解线性子问题的有效方法，这是这些直接方法的瓶颈。&lt;br&gt;我们将我们称为稀疏位姿调整（SPA）的方法与竞争间接方法进行比较，并表明它在收敛速度和准确性方面优于它们。&lt;br&gt;我们在大量室内真实世界地图和非常大的模拟数据集上展示了它的有效性。&lt;br&gt;C++中的开源实现和数据集是公开可用的。&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>冰箱收纳</title>
    <link href="http://lsy563193.github.io/homework-Refrigerator%20storage/"/>
    <id>http://lsy563193.github.io/homework-Refrigerator storage/</id>
    <published>2018-11-19T00:55:31.000Z</published>
    <updated>2018-11-19T05:30:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>灶台上<br>塑胶篮 —   碗碟常用餐具<br>伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子<br>毛巾架 —锅盖 防烫手套</p><p>灶台下<br>文件盒 — 平底锅<br>死角<br>伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 </p><p>水槽下<br>滤筛 清洁剂<br>伸缩棒 滤网 架子</p><p>毛巾架</p><p>水槽上边<br>旅馆 凹字形  做成抽屉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;灶台上&lt;br&gt;塑胶篮 —   碗碟常用餐具&lt;br&gt;伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子&lt;br&gt;毛巾架 —锅盖 防烫手套&lt;/p&gt;
&lt;p&gt;灶台下&lt;br&gt;文件盒 — 平底锅&lt;br&gt;死角&lt;br&gt;伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 &lt;/p&gt;
&lt;p&gt;水槽下&lt;
      
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>厨房收纳</title>
    <link href="http://lsy563193.github.io/homework-KitchenStorage/"/>
    <id>http://lsy563193.github.io/homework-KitchenStorage/</id>
    <published>2018-11-19T00:55:31.000Z</published>
    <updated>2018-11-19T05:28:00.174Z</updated>
    
    <content type="html"><![CDATA[<p>灶台上<br>塑胶篮 —   碗碟常用餐具<br>伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子<br>毛巾架 —锅盖 防烫手套</p><p>灶台下<br>文件盒 — 平底锅<br>死角<br>伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 </p><p>水槽下<br>滤筛 清洁剂<br>伸缩棒 滤网 架子</p><p>毛巾架</p><p>水槽上边<br>旅馆 凹字形  做成抽屉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;灶台上&lt;br&gt;塑胶篮 —   碗碟常用餐具&lt;br&gt;伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子&lt;br&gt;毛巾架 —锅盖 防烫手套&lt;/p&gt;
&lt;p&gt;灶台下&lt;br&gt;文件盒 — 平底锅&lt;br&gt;死角&lt;br&gt;伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 &lt;/p&gt;
&lt;p&gt;水槽下&lt;
      
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>健身笔记</title>
    <link href="http://lsy563193.github.io/health-Fitness/"/>
    <id>http://lsy563193.github.io/health-Fitness/</id>
    <published>2018-11-07T01:23:23.000Z</published>
    <updated>2018-11-19T05:31:53.436Z</updated>
    
    <content type="html"><![CDATA[<p>本文是硬派健身笔记汇总<br><a id="more"></a></p><p>训练计划</p><p>1 臀腿 大<br>3 肩 小<br>4 背 中<br>6 胸 大</p><p>1 臀腿 小<br>3 肩 中<br>5 背 大<br>6 胸 小</p><p>小 %85<br>中 %90<br>大 %100</p><p>（大训练量=100%max重量、中训练量=90%max、小训练量=85%max）</p><p>肩<br>男性肩部重点：前束&amp;中束<br>整体：推举&amp;整体训练要点（中等重量、多次数、多组数、力竭）</p><p>后束：俯身侧平举&amp;练肩不粗脖小技巧（内旋）</p><p>中束：侧平举&amp;侧平举训练要点（小重量、手臂微屈）</p><p>前束：前平举&amp;前平举训练要点（多次数、多组数、力竭训练）</p><p>肩部训练计划<br>哑铃平举</p><p>站姿<br>俯身侧<br>站姿侧<br>前<br>L侧</p><p>屈膝卷腹<br>反向卷腹<br>空中单车<br>开合跳<br>自重侧弓步<br>原地高抬腿<br>靠墙静坐<br>平板支撑</p><p>最佳<br>上腹肌 悬腿卷腹<br>下腹肌 垂悬举腿<br>整体 空中单车</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是硬派健身笔记汇总&lt;br&gt;
    
    </summary>
    
      <category term="运动康复" scheme="http://lsy563193.github.io/categories/%E8%BF%90%E5%8A%A8%E5%BA%B7%E5%A4%8D/"/>
    
    
      <category term="硬派健身" scheme="http://lsy563193.github.io/tags/%E7%A1%AC%E6%B4%BE%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>向量分析</title>
    <link href="http://lsy563193.github.io/%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>http://lsy563193.github.io/向量分析/</id>
    <published>2018-11-06T07:47:33.000Z</published>
    <updated>2018-11-06T09:39:46.337Z</updated>
    
    <content type="html"><![CDATA[<p>向量分析是数学的分支，关心拥有两个维度或以上的向量的多元实分析。它有一套方程式及难题处理技巧对物理学及工程学特别有帮助。在微分几何与偏微分方程的研究中起着重要作用。它被广泛应用于物理和工程中，特别是在描述电磁场、引力场和流体流动的时候。<br><a id="more"></a></p><p>ab<ad:ac:db></ad:ac:db></p><c></c>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;向量分析是数学的分支，关心拥有两个维度或以上的向量的多元实分析。它有一套方程式及难题处理技巧对物理学及工程学特别有帮助。在微分几何与偏微分方程的研究中起着重要作用。它被广泛应用于物理和工程中，特别是在描述电磁场、引力场和流体流动的时候。&lt;br&gt;
    
    </summary>
    
    
      <category term="数学分支" scheme="http://lsy563193.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ceres-solver examples之pose_graph_2d学习笔记</title>
    <link href="http://lsy563193.github.io/slam-ceres-cartographer-pose-graph/"/>
    <id>http://lsy563193.github.io/slam-ceres-cartographer-pose-graph/</id>
    <published>2018-11-06T07:25:06.000Z</published>
    <updated>2018-11-06T07:33:15.225Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs the nonlinear least squares optimization problem from the pose</span></span><br><span class="line"><span class="comment">// graph constraints.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildOptimizationProblem</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Constraint2d&gt;&amp; constraints,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;* poses,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ceres::Problem* problem)</span> </span>&#123;</span><br><span class="line">  CHECK(poses != <span class="literal">NULL</span>);</span><br><span class="line">  CHECK(problem != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (constraints.empty()) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"No constraints, no problem to optimize."</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ceres::LossFunction* loss_function = <span class="literal">NULL</span>;</span><br><span class="line">  ceres::LocalParameterization* angle_local_parameterization =</span><br><span class="line">      AngleLocalParameterization::Create();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Constraint2d&gt;::const_iterator constraints_iter =</span><br><span class="line">           constraints.begin();</span><br><span class="line">       constraints_iter != constraints.end(); ++constraints_iter) &#123;</span><br><span class="line">    <span class="keyword">const</span> Constraint2d&amp; constraint = *constraints_iter;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_begin_iter =</span><br><span class="line">        poses-&gt;find(constraint.id_begin);</span><br><span class="line">    CHECK(pose_begin_iter != poses-&gt;end())</span><br><span class="line">        &lt;&lt; <span class="string">"Pose with ID: "</span> &lt;&lt; constraint.id_begin &lt;&lt; <span class="string">" not found."</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_end_iter =</span><br><span class="line">        poses-&gt;find(constraint.id_end);</span><br><span class="line">    CHECK(pose_end_iter != poses-&gt;end())</span><br><span class="line">        &lt;&lt; <span class="string">"Pose with ID: "</span> &lt;&lt; constraint.id_end &lt;&lt; <span class="string">" not found."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix3d sqrt_information =</span><br><span class="line">        constraint.information.llt().matrixL();</span><br><span class="line">    <span class="comment">// Ceres will take ownership of the pointer.</span></span><br><span class="line">    ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(</span><br><span class="line">        constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);</span><br><span class="line">    problem-&gt;AddResidualBlock(</span><br><span class="line">        cost_function, loss_function, &amp;pose_begin_iter-&gt;second.x,</span><br><span class="line">        &amp;pose_begin_iter-&gt;second.y, &amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">        &amp;pose_end_iter-&gt;second.x, &amp;pose_end_iter-&gt;second.y,</span><br><span class="line">        &amp;pose_end_iter-&gt;second.yaw_radians);</span><br><span class="line"></span><br><span class="line">    problem-&gt;SetParameterization(&amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">                                angle_local_parameterization);</span><br><span class="line">    problem-&gt;SetParameterization(&amp;pose_end_iter-&gt;second.yaw_radians,</span><br><span class="line">                                angle_local_parameterization);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The pose graph optimization problem has three DOFs that are not fully</span></span><br><span class="line">  <span class="comment">// constrained. This is typically referred to as gauge freedom. You can apply</span></span><br><span class="line">  <span class="comment">// a rigid body transformation to all the nodes and the optimization problem</span></span><br><span class="line">  <span class="comment">// will still have the exact same cost. The Levenberg-Marquardt algorithm has</span></span><br><span class="line">  <span class="comment">// internal damping which mitigate this issue, but it is better to properly</span></span><br><span class="line">  <span class="comment">// constrain the gauge freedom. This can be done by setting one of the poses</span></span><br><span class="line">  <span class="comment">// as constant so the optimizer cannot change it.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_start_iter =</span><br><span class="line">      poses-&gt;begin();</span><br><span class="line">  CHECK(pose_start_iter != poses-&gt;end()) &lt;&lt; <span class="string">"There are no poses."</span>;</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.x);</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.y);</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.yaw_radians);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ceres-solver examples之pose_graph_2d学习笔记<br>ceres-solver库是google的非线性优化库，可以对slam问题，机器人位姿进行优化，使其建图的效果得到改善。pose_graph_2d是官方给出的二维平面上机器人位姿优化问题，需要读取一个g2o文件，运行程序后返回一个poses_original.txt和一个poses_optimized.txt，大家按字面意思理解，内部格式长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pose_id x y yaw_radians</span><br><span class="line">pose_id x y yaw_radians</span><br><span class="line">pose_id x y yaw_radians</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>得到这两个文件后，用官方提供的plot_results.py可以画出原始和优化后的位姿地图<br><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/ceres-pose-slam.png" alt="image"><br><a id="more"></a></p><h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><p>重要变量为以下几个：<br>constraints：vector，放入变量的类型为Constraint2d， 含义为机器人两个pose之间的限制，Constraint2d包括两个pose的id，相对坐标x，y，和协方差阵。这个变量描述的是观测量测量量measurement，即机器人认为自己感知到的正确的数据。</p><p>poses: map类指针，键值对为id和 Pose2d ，Pose2d是一个由id，世界坐标x，y，yaw角。这个变量描述的是实际机器人的世界坐标位置，是确确实实发生的事实。</p><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ceres will take ownership of the pointer.</span></span><br><span class="line"><span class="comment">//将需要的参数传入，设置残差，构造costfunction，使用自动求导方式</span></span><br><span class="line">ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(</span><br><span class="line">    constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);</span><br></pre></td></tr></table></figure><p>详情见下面的Costfunction的搭建。</p><h3 id="一、Costfunction的搭建"><a href="#一、Costfunction的搭建" class="headerlink" title="一、Costfunction的搭建"></a>一、Costfunction的搭建</h3><p>使用ceres库的关键是构造 costfunction ，ceres官方搭建的costfunction，同样有一个类表示，名为PoseGraph2dErrorTerm，具体如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoseGraph2dErrorTerm</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  PoseGraph2dErrorTerm(<span class="keyword">double</span> x_ab, <span class="keyword">double</span> y_ab, <span class="keyword">double</span> yaw_ab_radians,</span><br><span class="line">                       <span class="keyword">const</span> Eigen::Matrix3d&amp; sqrt_information)</span><br><span class="line">      : p_ab_(x_ab, y_ab),</span><br><span class="line">        yaw_ab_radians_(yaw_ab_radians),</span><br><span class="line">        sqrt_information_(sqrt_information) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="comment">//x_a,y_a(p_a)x_b,y_b(p_b)是世界下的ab坐标</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x_a, <span class="keyword">const</span> T* <span class="keyword">const</span> y_a, <span class="keyword">const</span> T* <span class="keyword">const</span> yaw_a,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> x_b, <span class="keyword">const</span> T* <span class="keyword">const</span> y_b, <span class="keyword">const</span> T* <span class="keyword">const</span> yaw_b,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals_ptr)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">1</span>&gt; p_a(*x_a, *y_a);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">1</span>&gt; p_b(*x_b, *y_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map映射类  将外部传进来的residuals_ptr映射到matrix&lt;3,1&gt;，取名为residuals_map</span></span><br><span class="line">    Eigen::Map&lt;Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; &gt; residuals_map(residuals_ptr);</span><br><span class="line"></span><br><span class="line">    residuals_map.<span class="keyword">template</span> head&lt;<span class="number">2</span>&gt;() =</span><br><span class="line">        RotationMatrix2D(*yaw_a).transpose() * (p_b - p_a) -</span><br><span class="line">        p_ab_.cast&lt;T&gt;();</span><br><span class="line">    residuals_map(<span class="number">2</span>) = ceres::examples::NormalizeAngle(</span><br><span class="line">        (*yaw_b - *yaw_a) - <span class="keyword">static_cast</span>&lt;T&gt;(yaw_ab_radians_));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale the residuals by the square root information matrix to account for</span></span><br><span class="line">    <span class="comment">// the measurement uncertainty.</span></span><br><span class="line">    residuals_map = sqrt_information_.<span class="keyword">template</span> cast&lt;T&gt;() * residuals_map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态成员函数 构造costfunction   AutoDiffCostFunction 残差参数为3维  其他参数每个1维(参数是operator里的参数)</span></span><br><span class="line">  <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">double</span> x_ab, <span class="keyword">double</span> y_ab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">double</span> yaw_ab_radians,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Eigen::Matrix3d&amp; sqrt_information)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;PoseGraph2dErrorTerm, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                            <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> PoseGraph2dErrorTerm(</span><br><span class="line">        x_ab, y_ab, yaw_ab_radians, sqrt_information)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The position of B relative to A in the A frame.</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Vector2d p_ab_;</span><br><span class="line">  <span class="comment">// The orientation of frame B relative to frame A.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> yaw_ab_radians_;</span><br><span class="line">  <span class="comment">// The inverse square root of the measurement covariance matrix.</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Matrix3d sqrt_information_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中包括：<br>一个构造函数PoseGraph2dErrorTerm(x_ab, y_ab, yaw_ab_radians, sqrt_information)；<br>一个运算符重载operator()(x_a, y_a, yaw_a, x_b, y_b, yaw_b, residuals_ptr)，其中residuals_ptr指向的东西是计算出的残差；<br>一个构造costfunction的函数Create(x_ab, y_ab, yaw_ab_radians,&amp; sqrt_information)。</p><p>operator()的作用<br>传入参数计算残差，残差有三维，如下所示：<br>residual = information1/2 <em> [ raT </em> (pb - pa) - hat( pab ) ] （2维）<br>[ Normalize(yawb - yawa - hat( yawab ) ) ] （1维）</p><p>其中ra  是 timestep a 时从当前坐标系转向世界坐标系的旋转矩阵， pb  和 pa 是世界坐标系下timestep a 和 b 时的机器人位置，带hat的是测量值，是在时刻a时机器人坐标系下观察的测量值。</p><p>Create函数的作用<br>用来构造一个costfunction类，与一般不同的是，main函数里调用Create函数来构造costfunction.<br>定义求导方式，官方例程里定义的是自动求导方式，即ceres::AutoDiffCostFunction，&lt;&gt;里的参数是我们的PoseGraph2dErrorTerm类，和优化变量的维数，详情见代码注释。</p><h3 id="二、构造Problem"><a href="#二、构造Problem" class="headerlink" title="二、构造Problem"></a>二、构造Problem</h3><p>当costfunction搭建好后，给每个constraint都加入残差快AddResidualBlock, 官方例程没有用核函数，传入costfunction，传入待优化参数即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加problem 待优化的参数和PoseGraph2dErrorTerm里的operator保持一致</span></span><br><span class="line">problem-&gt;AddResidualBlock(</span><br><span class="line">    cost_function, loss_function, &amp;pose_begin_iter-&gt;second.x,</span><br><span class="line">    &amp;pose_begin_iter-&gt;second.y, &amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">    &amp;pose_end_iter-&gt;second.x, &amp;pose_end_iter-&gt;second.y,</span><br><span class="line">    &amp;pose_end_iter-&gt;second.yaw_radians);</span><br></pre></td></tr></table></figure></p><h3 id="三、LocalParameterization搭建"><a href="#三、LocalParameterization搭建" class="headerlink" title="三、LocalParameterization搭建"></a>三、LocalParameterization搭建</h3><p>理论详情见( <a href="https://blog.csdn.net/HUAJUN998/article/details/76222745" target="_blank" rel="noopener">https://blog.csdn.net/HUAJUN998/article/details/76222745</a> ），目的是利用一个增量构造Jacobian矩阵更新变量，具体不是很懂。官方例程只用它优化了yaw角，官方例程按照ceres库内的autodiff_local_parameterization.h定义方法定义了一个AngleLocalParameterization类，写在了例程中的angle_local_parameterization.h中，如下所示：<br>// Defines a local parameterization for updating the angle to be constrained in<br>// [-pi to pi).<br>class AngleLocalParameterization {<br> public:</p><p>  template <typename t=""><br>  bool operator()(const T<em> theta_radians, const T</em> delta_theta_radians,<br>                  T<em> theta_radians_plus_delta) const {    </em>theta_radians_plus_delta =<br>        NormalizeAngle(<em>theta_radians + </em>delta_theta_radians);</typename></p><pre><code>return true;</code></pre><p>  }</p><p>  //构造LocalParameterization函数，使用自动求导<br>  //参数目前不懂什么意思，应该是operator中输入输出参数的维数，Global Size和Local size<br>  static ceres::LocalParameterization* Create() {<br>    return (new ceres::AutoDiffLocalParameterization<anglelocalparameterization, 1="" 1,="">);<br>  }<br>};</anglelocalparameterization,></p><p>然后在主程序制造优化问题时，在迭代constraints之前就create了角度的localparameterization：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造yaw角度的localparameterization，更新角度 yaw_new = yaw + △yaw</span></span><br><span class="line">ceres::LocalParameterization* angle_local_parameterization =</span><br><span class="line">    AngleLocalParameterization::Create();</span><br></pre></td></tr></table></figure></p><p>等到迭代遍历时，就加入了每一个constraint内两个pose的yaw角，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为yaw角设置localparameterization</span></span><br><span class="line">problem-&gt;SetParameterization(&amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">                            angle_local_parameterization);</span><br><span class="line">problem-&gt;SetParameterization(&amp;pose_end_iter-&gt;second.yaw_radians,</span><br><span class="line">                            angle_local_parameterization);</span><br></pre></td></tr></table></figure></p><h3 id="四、固定初始位姿"><a href="#四、固定初始位姿" class="headerlink" title="四、固定初始位姿"></a>四、固定初始位姿</h3><p>官方例程上讲，优化问题是三个自由度的，没有造成互相之间完全的限制，这个问题叫做规范自由度（gauge freedom），详情见规范固定 ，具体不懂，反正按官方例程的意思是要固定第一个pose，不让它进行优化。<br>  // The pose graph optimization problem has three DOFs that are not fully<br>  // constrained. This is typically referred to as gauge freedom. You can apply<br>  // a rigid body transformation to all the nodes and the optimization problem<br>  // will still have the exact same cost. The Levenberg-Marquardt algorithm has<br>  // internal damping which mitigate this issue, but it is better to properly<br>  // constrain the gauge freedom. This can be done by setting one of the poses<br>  // as constant so the optimizer cannot change it.<br>  //规范固定，通过将一个pose设定成常量来限制规范自由度，具体含义不懂<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_start_iter =</span><br><span class="line">    poses-&gt;begin();</span><br><span class="line">CHECK(pose_start_iter != poses-&gt;end()) &lt;&lt; <span class="string">"There are no poses."</span>;</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.x);</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.y);</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.yaw_radians);</span><br></pre></td></tr></table></figure></p><p>五、相关链接<br>以上是程序的主要问题，关于cpp的基础知识可参考下方链接：<br>ceres-solver官方教程</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Constructs the nonlinear least squares optimization problem from the pose&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// graph constraints.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BuildOptimizationProblem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;Constraint2d&amp;gt;&amp;amp; constraints,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                              &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;* poses,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                              ceres::Problem* problem)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(poses != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(problem != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (constraints.empty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOG(INFO) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;No constraints, no problem to optimize.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ceres::LossFunction* loss_function = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ceres::LocalParameterization* angle_local_parameterization =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      AngleLocalParameterization::Create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;Constraint2d&amp;gt;::const_iterator constraints_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           constraints.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       constraints_iter != constraints.end(); ++constraints_iter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Constraint2d&amp;amp; constraint = *constraints_iter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_begin_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        poses-&amp;gt;find(constraint.id_begin);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHECK(pose_begin_iter != poses-&amp;gt;end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Pose with ID: &quot;&lt;/span&gt; &amp;lt;&amp;lt; constraint.id_begin &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot; not found.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_end_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        poses-&amp;gt;find(constraint.id_end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHECK(pose_end_iter != poses-&amp;gt;end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Pose with ID: &quot;&lt;/span&gt; &amp;lt;&amp;lt; constraint.id_end &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot; not found.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Eigen::Matrix3d sqrt_information =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraint.information.llt().matrixL();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Ceres will take ownership of the pointer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;AddResidualBlock(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cost_function, loss_function, &amp;amp;pose_begin_iter-&amp;gt;second.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_begin_iter-&amp;gt;second.y, &amp;amp;pose_begin_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_end_iter-&amp;gt;second.x, &amp;amp;pose_end_iter-&amp;gt;second.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_end_iter-&amp;gt;second.yaw_radians);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;SetParameterization(&amp;amp;pose_begin_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                angle_local_parameterization);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;SetParameterization(&amp;amp;pose_end_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                angle_local_parameterization);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// The pose graph optimization problem has three DOFs that are not fully&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// constrained. This is typically referred to as gauge freedom. You can apply&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// a rigid body transformation to all the nodes and the optimization problem&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// will still have the exact same cost. The Levenberg-Marquardt algorithm has&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// internal damping which mitigate this issue, but it is better to properly&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// constrain the gauge freedom. This can be done by setting one of the poses&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// as constant so the optimizer cannot change it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_start_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      poses-&amp;gt;begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(pose_start_iter != poses-&amp;gt;end()) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;There are no poses.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.yaw_radians);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Ceres-solver examples之pose_graph_2d学习笔记&lt;br&gt;ceres-solver库是google的非线性优化库，可以对slam问题，机器人位姿进行优化，使其建图的效果得到改善。pose_graph_2d是官方给出的二维平面上机器人位姿优化问题，需要读取一个g2o文件，运行程序后返回一个poses_original.txt和一个poses_optimized.txt，大家按字面意思理解，内部格式长这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到这两个文件后，用官方提供的plot_results.py可以画出原始和优化后的位姿地图&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/ceres-pose-slam.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>latex</title>
    <link href="http://lsy563193.github.io/tools-latex/"/>
    <id>http://lsy563193.github.io/tools-latex/</id>
    <published>2018-11-06T06:30:44.034Z</published>
    <updated>2018-11-06T06:30:44.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><p><a href="https://linux.cn/article-10172-1.html" target="_blank" rel="noopener">用这个漂亮的工具将方程式截图迅速转换为 LaTeX</a></p><p><a href="http://www.domuse.com/markdown-and-latex-equation-handbook.html" target="_blank" rel="noopener">Markdown语法和LaTeX数学记号速查手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;latex&quot;&gt;&lt;a href=&quot;#latex&quot; class=&quot;headerlink&quot; title=&quot;latex&quot;&gt;&lt;/a&gt;latex&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://linux.cn/article-10172-1.html&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具教程" scheme="http://lsy563193.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="工具" scheme="http://lsy563193.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达《深度学习》系列课程个人笔记</title>
    <link href="http://lsy563193.github.io/deep-learning-AndrewNgDeepLearningNotes/"/>
    <id>http://lsy563193.github.io/deep-learning-AndrewNgDeepLearningNotes/</id>
    <published>2018-11-06T04:26:45.337Z</published>
    <updated>2018-11-06T04:26:45.337Z</updated>
    
    <content type="html"><![CDATA[<p>吴恩达《深度学习》系列课程个人笔记<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吴恩达《深度学习》系列课程个人笔记&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://lsy563193.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Testing" scheme="http://lsy563193.github.io/tags/Testing/"/>
    
      <category term="Another Tag" scheme="http://lsy563193.github.io/tags/Another-Tag/"/>
    
  </entry>
  
  <entry>
    <title>Scan Matching in 2D SLAM by 张明明</title>
    <link href="http://lsy563193.github.io/slam-lidar-scan-matching-in-2d-slam/"/>
    <id>http://lsy563193.github.io/slam-lidar-scan-matching-in-2d-slam/</id>
    <published>2018-11-06T02:03:04.000Z</published>
    <updated>2018-11-06T04:24:14.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明"><a href="#【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明" class="headerlink" title="【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明"></a>【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明</h2><a id="more"></a><h2 id="概述-Scan-Matching"><a href="#概述-Scan-Matching" class="headerlink" title="概述 Scan Matching"></a>概述 Scan Matching</h2><p>两类<br>Real-Time Loop Cloare in 2D LIDAR SLAM.ICRA2016,提到scan matching的两种方法</p><h3 id="scan-to-ccan-—ICP-etc"><a href="#scan-to-ccan-—ICP-etc" class="headerlink" title="scan-to-ccan —ICP,etc"></a>scan-to-ccan —ICP,etc</h3><ul><li>计算成本大</li><li>累积误差,需进行闭环</li><li>容易进行闭环检测<h3 id="scan-to-map-matching-—Hector-SLAM-etc"><a href="#scan-to-map-matching-—Hector-SLAM-etc" class="headerlink" title="scan-to-map matching —Hector SLAM,etc"></a>scan-to-map matching —Hector SLAM,etc</h3></li><li>误差累积小计算成本小</li><li>难以闭环<br>更进一步的算法</li></ul><h2 id="2-ICP"><a href="#2-ICP" class="headerlink" title="2.ICP"></a>2.ICP</h2><h3 id="PL-ICP-开源-ros"><a href="#PL-ICP-开源-ros" class="headerlink" title="PL-ICP(开源,ros)"></a>PL-ICP(开源,ros)</h3><p>典型的是PL-ICP,一般icp是点到点的二阶最小均平和(ICP variant using a point to linear metric ICRA2009),速度快,大的旋转不够鲁棒<br>公式:<br>论文:</p><h3 id="PL-ICP加闭环（g2o）"><a href="#PL-ICP加闭环（g2o）" class="headerlink" title="PL-ICP加闭环（g2o）"></a>PL-ICP加闭环（g2o）</h3><ul><li>关键帧的选择策略</li><li><p>如何闭环<br>对之前的关键帧进行搜索</p></li><li><ol><li>有一个大的旋转就选择一个关键帧<br>缺点：没有submap(基于视觉的闭环),</li></ol></li><li><ol><li>有个局部小闭环，</li></ol></li><li><ol><li>google 也是一个小闭环(不开源)<h3 id="Hector-Slam"><a href="#Hector-Slam" class="headerlink" title="　Hector Slam"></a>　Hector Slam</h3></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明&quot;&gt;&lt;a href=&quot;#【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明&quot; class=&quot;headerlink&quot; title=&quot;【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明&quot;&gt;&lt;/a&gt;【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明&lt;/h2&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>graph slam ceres 实现</title>
    <link href="http://lsy563193.github.io/slam-GraphSLAM-ceres/"/>
    <id>http://lsy563193.github.io/slam-GraphSLAM-ceres/</id>
    <published>2018-11-06T02:03:04.000Z</published>
    <updated>2018-11-06T04:18:56.198Z</updated>
    
    <content type="html"><![CDATA[<p>本文是graph-slam 理论部分: ceres的实现部分<br><a id="more"></a></p><script type="math/tex; mode=display">e = (x_0)^2 + (x_1 - x_0 - 1)^2 + (l_0 - x_0 - 2)^2 + (l_0 - x_1 - 0.8)^2</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gflags/gflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F1</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f1 = x0;</span></span><br><span class="line">    residual[<span class="number">0</span>] = x1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F2</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f2 = (x1 - x0 -1.0)</span></span><br><span class="line">    residual[<span class="number">0</span>] = x1[<span class="number">0</span>] - x0[<span class="number">0</span>] - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F3</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> l0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f3 = l0 - x0 - 2.0</span></span><br><span class="line">    residual[<span class="number">0</span>] = l0[<span class="number">0</span>] - x0[<span class="number">0</span>] - <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F4</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> l0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f4 = lo - x1 - 0.8</span></span><br><span class="line">    residual[<span class="number">0</span>] = l0[<span class="number">0</span>] - x1[<span class="number">0</span>] - <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DEFINE_string(minimizer, <span class="string">"trust_region"</span>,</span><br><span class="line">              <span class="string">"Minimizer type to use, choices are: line_search &amp; trust_region"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  CERES_GFLAGS_NAMESPACE::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> x0 =  <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x1 = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">double</span> l0 =  <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//  double x4 =  1.0;</span></span><br><span class="line"></span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="comment">// Add residual terms to the problem using the using the autodiff</span></span><br><span class="line">  <span class="comment">// wrapper to get the derivatives automatically. The parameters, x0 through</span></span><br><span class="line">  <span class="comment">// x4, are modified in place.</span></span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F1),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x0, &amp;x1);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F2, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F2),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x1, &amp;x0);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F3, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F3),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;l0, &amp;x0);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F4),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;l0, &amp;x1);</span><br><span class="line"></span><br><span class="line">  Solver::Options options;</span><br><span class="line">  LOG_IF(FATAL, !ceres::StringToMinimizerType(FLAGS_minimizer,</span><br><span class="line">                                              &amp;options.minimizer_type))</span><br><span class="line">      &lt;&lt; <span class="string">"Invalid minimizer: "</span> &lt;&lt; FLAGS_minimizer</span><br><span class="line">      &lt;&lt; <span class="string">", valid options are: trust_region and line_search."</span>;</span><br><span class="line"></span><br><span class="line">  options.max_num_iterations = <span class="number">100</span>;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial x0 = "</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>)&lt;&lt; x0</span><br><span class="line">            &lt;&lt; <span class="string">", x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", l0 = "</span> &lt;&lt; l0</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the solver!</span></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final x0 = "</span> &lt;&lt; x0</span><br><span class="line">            &lt;&lt; <span class="string">", x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", l0 = "</span> &lt;&lt; l0</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://ceres-solver.org/nnls_tutorial.html#powell-s-function" target="_blank" rel="noopener">ceres-solver官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是graph-slam 理论部分: ceres的实现部分&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>graph slam 理论</title>
    <link href="http://lsy563193.github.io/slam-GraphSLAM-theory/"/>
    <id>http://lsy563193.github.io/slam-GraphSLAM-theory/</id>
    <published>2018-11-05T03:03:04.000Z</published>
    <updated>2018-11-06T06:58:44.867Z</updated>
    
    <content type="html"><![CDATA[<p>graph slam 理论<br><a id="more"></a></p><h2 id="什么是graph-slam"><a href="#什么是graph-slam" class="headerlink" title="什么是graph slam"></a>什么是graph slam</h2><p>图优化是比较常用的后端优化，cartographer也用到了这个方法。<br>假设有个一机器人，在初始位置$x_0$为0，先前移动1，看到了路标$l_0$为2，到达$x_2$的位置之后看到路标$l_0$的距离时0.8, 如图所示:</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/grapher_slam.png" alt="graph_slam"></p><p>从$x_0$到$x_1$的距离其实是不确定的，不能够以1来表示，因为会有误差，学过卡尔曼就知道他的概率分布其实是</p><script type="math/tex; mode=display">\frac{1}{\sqrt{2\pi\delta}}\exp^{1/2}\frac{(x_1 - x_0 - 1)^2}{\delta^2}</script><p>是一个距离x0为1的正态分布。</p><p>上图中同样其他的边也是展示了这种节点与节点的约束.我们要做的就是通过建立这中约束然后通过这种约束求得最优解。<br>上图中有三种约束：</p><script type="math/tex; mode=display">x_0 : 0 \\x_0 -> x_1: 1 \\x_0 -> l_0: 2 \\x_1 -> l_0: 0.8</script><p>其中$x_0=0$被称为”初始位姿约束”</p><p>$x_0 -&gt; x_1: 1$被称为”初始位姿约束”</p><p>$x_0 -&gt; l_0: 2 x_1 -&gt; l_0: 0.8$ 为 “相对测量约束”</p><p>这些约束只有初始位姿约束时绝对的，所以在后面优化之后初始位姿不会变，这也要求初始位精度一定要高，不然后面的推断都会出错</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>我们现在讲解一下求解最优值的过程，根据上面的约束，我们可以得到四个方程</p><script type="math/tex; mode=display">\left \lbrace\begin{aligned}    x_0 = 0 \\    x_1 - x_0 -1 = 0 \\    l_0 - x_0 - 2 = 0 \\    l_0 - x_1 - 0.8 = 0\end{aligned}\right .</script><p>使用最小二乘法</p><!-- $$ --><!-- \underset{x}{min} \frac{1}{2}(||f_{i_1}(x_{i_1, ... , x_{i_k}})||^2) --><!-- $$ --><script type="math/tex; mode=display">\underset{x}{min}\sum_i^4e() =  = (x_0)^2 + (x_1 - x_0 - 1)^2 + (l_0 - x_0 - 2)^2 + (l_0 - x_1 - 0.8)^2</script><p>分别对$x_0$, $x_1$, $l_0$求偏导数</p><script type="math/tex; mode=display">\begin{array} { l } { \frac { \partial c } { \partial x _ { 0 } } = 2 x _ { 0 } - 2 \left( x _ { 1 } - x _ { 0 } - 1 \right) - 2 \left( l _ { 0 } - x _ { 0 } - 2 \right) } = 0\\ { \frac { \partial c } { \partial x _ { 1 } } = 2 \left( x _ { 1 } - x _ { 0 } - 1 \right) - 2 \left( l _ { 0 } - x _ { 1 } - 0.8 \right) } = 0\\  { \frac { \partial c } { \partial l _ { 0 } } = 2 \left( l _ { 0 } - x _ { 0 } - 2 \right) + 2 \left( l _ { 0 } - x _ { 1 } - 0.8 \right) }  =0\end{array}</script><p>最终得到</p><script type="math/tex; mode=display">\left[ \begin{array} { c c c } { 3 } & { - 1 } & { - 1 } \\ { - 1 } & { 2 } & { - 1 } \\ { - 1 } & { - 1 } & { 2 } \end{array} \right] \left[ \begin{array} { c } { x _ { 0 } } \\ { x _ { 1 } } \\ { l _ { 0 } } \end{array} \right] = \left[ \begin{array} { r } { - 3.0 } \\ { 0.2 } \\ { 2.8 } \end{array} \right] \quad \text { or } \quad \Omega \mu = \xi</script><p>接着矩阵求解线性方程组：</p><script type="math/tex; mode=display">\mu = \Omega ^ { - 1 } \xi = \left[ \begin{array} { c c c } { 3 } & { - 1 } & { - 1 } \\ { - 1 } & { 2 } & { - 1 } \\ { - 1 } & { - 1 } & { 2 } \end{array} \right] ^ { - 1 } \left[ \begin{array} { r } { - 3.0 } \\ { 0.2 } \\ { 2.8 } \end{array} \right] = \left[ \begin{array} { r } { 0 } \\ { 1.07 } \\ { 1.93 } \end{array} \right]</script><p>得到路标和机器人位姿：</p><script type="math/tex; mode=display">x _ { 0 } = 0 , x _ { 1 } = 1.07 , \text { and } l _ { 0 } = 1.93</script><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>// todo</p><h2 id="裁简"><a href="#裁简" class="headerlink" title="裁简"></a>裁简</h2><p>// todo</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/playlist?list=PLAwxTw4SYaPkCSYXw6-a_aAoXVKLDwnHK" target="_blank" rel="noopener">udacity ai-for robots 系列视频306到332</a></p><p><a href="https://blog.csdn.net/heyijia0327/article/details/47686523" target="_blank" rel="noopener">graph slam tutorial : 从推导到应用1</a></p><p><a href="https://www.cnblogs.com/gaoxiang12/p/5244828.html" target="_blank" rel="noopener">深入理解图优化与g2o：图优化篇</a></p><p><a href="https://blog.csdn.net/jsgaobiao/article/details/65628918" target="_blank" rel="noopener">Cartographer的原理探究——GraphSLAM理论基础</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;graph slam 理论&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer 调参日记</title>
    <link href="http://lsy563193.github.io/slam-cartographer-turn/"/>
    <id>http://lsy563193.github.io/slam-cartographer-turn/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:18:48.254Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer 2d 调参</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>使用1.0.0版本,因为公司扫地机用的是indigo版本,而我本机是用kinect版,所以我使用了docker来查看和调用rviz<br>Docker.indigo需要做些更改</p><ul><li>ARG CARTOGRAPHER_VERSION=release-1.0</li><li>cmake 升级到3.2版以上</li><li></li></ul><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>第一天<br>先从’/opt/ros/indigo/share/cartographer_ros/configuration’,如果找不到再到’/usr/share/cartographer-ros’找</p><ul><li>map 通常是map</li><li><strong>tracking_frame</strong>: 由SLAM算法跟踪的帧的ROS帧ID。如果使用IMU，它应该在其位置，尽管它可能是旋转的。一个常见的选择是“imu_link”。 不明,不用imu,写了odom,</li><li><strong>published_frame</strong>: ROS帧ID用作发布姿势的子帧。例如，如果“odom”帧由系统的不同部分提供，则为“odom”。在这种情况下，map_frame中的“ odom ” 姿势将被发布。否则，将其设置为“base_link”可能是合适的。 不明,写了odom</li><li><strong>odom_frame</strong>: 仅在provide_odom_frame为true时使用。published_frame 和map_frame之间的框架，用于发布（非循环关闭）本地SLAM结果。通常是“odom”。</li><li><strong>provide_odom_frame</strong>: 如果启用，则本地非闭环连续姿势将作为map_frame中的odom_frame发布。</li><li><strong>use_odometry</strong>: 如果启用，请在主题“ odom ”上订阅nav_msgs / Odometry。在这种情况下必须提供测距，并且信息将包含在SLAM中</li></ul><p>2d</p><ul><li>use_imu_data  如果不用false<br>先关闭全局slam</li><li>hit_probability 激光击中黑的程度</li><li>miss_probability 激光击不中白的程度</li></ul><p>online_correlative_scan_matching 更新initial_ceres_pose位置<br>ceres_scan_matcher_ pose_observation ,summary</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer 2d 调参&lt;/p&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析之local_slam</title>
    <link href="http://lsy563193.github.io/slam-cartographer-local_slam/"/>
    <id>http://lsy563193.github.io/slam-cartographer-local_slam/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:20:07.729Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析之local_slam<br><a id="more"></a></p><h2 id="LocalTrajectoryBuilder"><a href="#LocalTrajectoryBuilder" class="headerlink" title="LocalTrajectoryBuilder"></a>LocalTrajectoryBuilder</h2><p>Returns ‘MatchingResult’ when range data accumulation completed,<br>otherwise ‘nullptr’. Range data must be approximately horizontal<br>for 2D SLAM. <code>TimedPointCloudData::time</code> is when the last point in<br><code>range_data</code> was acquired, <code>TimedPointCloudData::ranges</code> contains the<br>relative time of point with respect to <code>TimedPointCloudData::time</code>.</p><h3 id="LocalTrajectoryBuilder-1"><a href="#LocalTrajectoryBuilder-1" class="headerlink" title="LocalTrajectoryBuilder"></a>LocalTrajectoryBuilder</h3><p>AddImuData添加imuData</p><h3 id="extrapolator"><a href="#extrapolator" class="headerlink" title="extrapolator_"></a>extrapolator_</h3><p>局部地图的位姿推断器。cartographer_ros不一样,addImuData时添加</p><h3 id="雷达数据的处理过程"><a href="#雷达数据的处理过程" class="headerlink" title="雷达数据的处理过程"></a>雷达数据的处理过程</h3><p>Node::HandleLaserScanMessage<br>SensorBridge::HandleLaserScanMessage<br>    ToPointCloudWithIntensities<br>    HandleLaserScan<br>    HandleRangefinder<br>CollatedTrajectoryBuilder  AddSensorData<br>    AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>    Dispatch<br>    callback</p><p>global_trajectory_builder::AddSensorData<br>LocalTrajectoryBuilder2D::AddRangeData<br>RangeDataCollator::AddRangeData<br>    extrapolator_-&gt;ExtrapolatePose<br>    accumulated_range_data_<br>    TransformToGravityAlignedFrameAndFilter<br>AddAccumulatedRangeData<br>TransformRangeData<br><!-- ScanMatch --><br><!-- InsertIntoSubmap --><br>local_slam_result_callback_<br>OnLocalSlamResult<br>GetTrajectoryStates<br>scan_matched_point_cloud_publisher_</p><h3 id="Imu的处理过程"><a href="#Imu的处理过程" class="headerlink" title="Imu的处理过程"></a>Imu的处理过程</h3><p>Node::HandleImuMessage<br>    sensor_samplers_ 分频，脉冲未到不处理<br>    extrapolators_.at(trajectory_id).AddImuData<br>SensorBridge::HandleImuMessage<br>CollatedTrajectoryBuilder::AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>BlockingQueue::Push, Dispatch callback<br>LocalTrajectoryBuilder2D::AddImuData<br>PoseExtrapolator::AddImuData<br>PoseGraph2D::AddImuData<br>OptimizationProblem2D::AddImuData</p><h3 id="Odometry的处理过程"><a href="#Odometry的处理过程" class="headerlink" title="Odometry的处理过程"></a>Odometry的处理过程</h3><p>Node::HandleOdometryMessage<br>    sensor_samplers_ 分频，脉冲未到不处理<br>    extrapolators_.at(trajectory_id).AddOdometryData  角速度和线速度<br>SensorBridge::HandleOdometryMessage<br>CollatedTrajectoryBuilder::AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>BlockingQueue::Push, Dispatch callback<br>LocalTrajectoryBuilder2D::AddOdometryData<br>PoseExtrapolator::AddOdometryData<br>PoseGraph2D::AddOdometryData<br>OptimizationProblem2D::AddOdometryData</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析之local_slam&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析之sensor</title>
    <link href="http://lsy563193.github.io/slam-cartographer-sensor/"/>
    <id>http://lsy563193.github.io/slam-cartographer-sensor/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:28:01.928Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析之sensor<br><a id="more"></a></p><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><p>ImuTracker:  使用IMU的角速度和线性加速度跟踪方向。 因为平均线性加速度（假设慢速运动）是重力的直接测量，所以滚动/俯仰不会漂移，尽管是偏航。</p><p>Map_build: 使用用于局部子图TrajectoryBuilders和用于闭环的PoseGraph来连接整个SLAM堆栈。<br>成员只有五个  MapBuilderOptions; thread_pool_; pose_graph_; CollatorInterface sensor_collator_; trajectory_builders_ all_trajectory_builder_options_; ,其中pose_graph_用于全局优化，<br>  trajectory_builders_用于子地图构建. sensor_collator_ 用于数据收集<br>  我们先看sensor_collator_,<br>sensor_collator_ SensorInterface</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p>  图优化</p><p>  <a href="https://blog.csdn.net/u012209790/article/details/82629422" target="_blank" rel="noopener">Real-time correlative scan matching 论文算法分析</a><br>  <a href="https://blog.csdn.net/u012209790/article/details/82735923" target="_blank" rel="noopener">Cartographer 的前端算法思路</a></p><p>  <a href="https://docs.ros.org/api/cartographer/html/classcartographer_1_1mapping_1_1constraints_1_1ConstraintBuilder2D.html" target="_blank" rel="noopener">cartographer Documentation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析之sensor&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析</title>
    <link href="http://lsy563193.github.io/slam-cartographer-notes/"/>
    <id>http://lsy563193.github.io/slam-cartographer-notes/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-28T09:08:39.638Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析流程<br><a id="more"></a></p><p>AddNode</p><p>核心函数是ComputeConstraintsForNode,为节点添加约束，并且在后台开始扫描匹配.<br>node_id是分配的节点号，insertion_submap是允许插入的子地图，即最后两张，newly_finished_submap最后第二张子地图是否刚满（完成）<br>WorkItem::Result ComputeConstraintsForNode(node_id, insertion_submaps, newly_finished_submap);</p><p>ComputeConstraintsForNode</p><ol><li>把轨迹节点添加到optimization_problem_.<br>optimization_problem_-&gt;AddTrajectoryNode(<pre><code> matching_id.trajectory_id, optimization::NodeSpec2D{constant_data-&gt;time, local_pose_2d,                          global_pose_2d,                          constant_data-&gt;gravity_alignment})</code></pre>2.遍历正在插入子图，填充图优化数据中的子地图数据和内部约束。<br>data_.submap_data.at(submap_id).node_ids.emplace(node_id);<br>data_.constraints.push_back(<pre><code>   Constraint{submap_id,              node_id,              {transform::Embed3D(constraint_transform),               options_.matcher_translation_weight(),               options_.matcher_rotation_weight()},              Constraint::INTRA_SUBMAP});</code></pre></li></ol><p>trajectory_nodes_.at(node_id).constant_data<br>constant_data-&gt;local_pose()<br>submap.local_pose()</p><p>constraint_transform</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析流程&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer论文翻译:2d-lidar-slam的实时闭环</title>
    <link href="http://lsy563193.github.io/slam-real-time-loop-closure-in-2d-lidar-slam/"/>
    <id>http://lsy563193.github.io/slam-real-time-loop-closure-in-2d-lidar-slam/</id>
    <published>2018-08-07T03:03:04.000Z</published>
    <updated>2018-12-13T01:40:42.085Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer 论文翻译<br><a id="more"></a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>LIDAR SLAM是获取平面地图的有效方法。  构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和<code>闭环</code>。 为了实现实时<code>闭环</code>，我们使用branch-and-bound将扫描到Submap匹配计算为约束。</p><h2 id="I-简介"><a href="#I-简介" class="headerlink" title="I. 简介"></a>I. 简介</h2><p>本文的贡献是一种新的方法，用于降低计算激光数据的闭环约束的需求量。</p><h2 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h2><p><code>Scan-to-scan matching</code>经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 它的缺点是很快就会累积误差。</p><p><code>Scan-to-map matching</code>有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。<br>在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的<code>Scan-to-map matching</code>是有效且稳健的。<br>在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。</p><p><code>pixel-accurate scan matching</code>方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于<code>闭环检测</code>很有用。</p><p>一些方法着重于通过匹配激光扫描的<code>提取特征</code>来改善计算成本[4]。其他用于<code>闭环检测</code>方法包括<code>基于直方图的匹配</code>[6]，扫描数据中的<code>特征检测</code>，以及使用<code>机器学习</code>[7]。</p><p><code>解决累积局部误差</code>的两种常用方法是<code>粒子滤波器</code>和<code>基于图形</code>的SLAM [2]，[8]。</p><p><code>基于图形</code>的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。<br>在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部<code>scan-to-scan</code>匹配，以及基于Submap特征的直方图的重叠局部图的匹配。</p><h2 id="III-系统概述"><a href="#III-系统概述" class="headerlink" title="III. 系统概述"></a>III. 系统概述</h2><p>Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 <code>Laser scans</code>被插入到最优估算位姿的Submap中，假定在短时间内足够准确。 而<code>Scan match</code>发生在最近的<code>Submap</code>上，因此它只取决于最近的扫描，全局误差会累积。</p><p>cartographer <code>定期</code>运行<code>位姿优化</code>来减少误差积累。<br>当一个Submap完成时，就不会再将新的扫描插入其中，它将参与<code>Scan match</code>以获得<code>闭环</code>。<br>所有已完成的Submap和扫描都会自动考虑进行<code>闭环</code>。<br>如果它们基于当前的<code>位姿估计</code>足够<code>接近</code>，则<code>Scan match器</code>试图在Submap中找到扫描。<br>如果在当前<code>估计位姿</code>的<code>搜索窗口</code>中找到足够好的匹配，则将其作为<code>闭环约束</code>添加到<code>优化问题</code>。</p><p>通过每隔几秒完成一次优化，我们的经验就是当<code>重新访问位置</code>时<code>立即闭环</code>。<br>这导致了<code>软实时约束</code>，即<code>闭环Scan match</code>必须比添加新扫描更快，否则它会明显落后,闭环失败。<br>我们通过对每个完成的Submap使用<code>branch-and-bound</code>和几个<code>预先计算的网格</code>来实现这一点。</p><h2 id="IV-局部2d-slam"><a href="#IV-局部2d-slam" class="headerlink" title="IV. 局部2d slam"></a>IV. 局部2d slam</h2><p>我们的系统将单独的局部和全局方法结合到2D SLAM中。<br>两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为<code>扫描</code>。<br>在不平的地面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。<br>在我们的局部方法中，每个连续扫描与<code>Submap</code>相匹配，使用<code>非线性优化</code>将扫描与Submap对齐; 该过程称为<code>real time Scan match</code>,其随着时间累积误差，我们的全局方法将其去除，如第五节所述。</p><h3 id="A-Scans"><a href="#A-Scans" class="headerlink" title="A. Scans"></a>A. Scans</h3><p>Submap构造是重复对齐scan和Submap坐标帧的迭代过程。<br>随着扫描的原点在$0 \in \Bbb R^2$，我们现在将关于扫描点的信息写为$H = \lbrace h_k\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$。<br>Submap帧中扫描帧的姿态$\xi$表示为变换$T_\xi$，它将扫描点从扫描帧严格转换为Submap帧，定义为</p><script type="math/tex; mode=display">T_\xi = \underbrace{\left(    \begin {matrix}        cos\xi_\delta & -sin\xi_\delta \\        sin\xi_\delta & sin\xi_\delta    \end{matrix} \right)}_{R_\xi}p +\underbrace{\left(\begin {matrix}     \xi_x \\    \xi_y\end{matrix} \right)}_{t_\xi}.\tag1</script><h3 id="B-Submaps"><a href="#B-Submaps" class="headerlink" title="B. Submaps"></a>B. Submaps</h3><p>一些连续扫描用于构建Submap。<br>这些Submap采用概率网格的形式$M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$，它以给定分辨率<code>r</code>的离散网格点进行映射，例如5厘米，到值。<br>这些值可以被认为是网格点被阻挡的概率。<br>对于每个网格点，我们将相应的<code>像素</code>定义为最接近该网格点的所有点。<br>每当要将扫描插入概率网格时，计算用于命中的一组网格点和用于未命中的不相交组。<br>对于每次击中，我们将最近的网格点插入到命中集中。<br>对于每个未命中，我们插入与每个像素相关联的网格点，该网格点与扫描原点和每个扫描点之间的一条光线相交，不包括已经在命中集中的网格点。<br>如果每个以前未观察到的网格点位于其中一个集合中，则会为其分配概率$p_{hit}$ 或 $p_{miss}$。<br>如果已经观察到网格点x，我们更新命中和未命中的几率</p><script type="math/tex; mode=display">odds(p) = \frac{p}{1-p}, \tag1</script><script type="math/tex; mode=display">M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1</script><p>and equivalently for misses</p><p>等同于未命中</p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/carto_submap.png?raw=true" alt="image"></p><h3 id="C-Ceres-scan-matching"><a href="#C-Ceres-scan-matching" class="headerlink" title="C. Ceres scan matching"></a>C. Ceres scan matching</h3><p>在将扫描插入Submap之前，扫描位姿<code>ξ</code>相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到<code>最大概率</code>的扫描位姿。 我们将其视为<code>非线性最小二乘问题</code></p><script type="math/tex; mode=display"> \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2</script><p>其中$T\xi$根据扫描位姿将$h_k$从scan帧变换到Submap帧。<br>函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。<br>我们使用双三次插值。<br>结果，可以发生区间$[0, 1]$之外的值，但是被认为是无关紧要的。<br>这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。<br>由于这是局部优化，因此需要良好的初始估计。<br>能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。<br>虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。</p><h2 id="V-闭环"><a href="#V-闭环" class="headerlink" title="V. 闭环"></a>V. 闭环</h2><p>由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。<br>对于仅几十次连续扫描，累积误差很小。<br>通过创建许多小Submap来处理更大的空间。<br>我们的方法，优化所有扫描和Submap的位姿，遵循<code>稀疏位姿调整</code>[2]。<br>插入扫描的相对位姿存储在内存中，以用于<code>闭环优化</code>。<br>除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由scan和Submap组成的对都被认为是<code>闭环</code>。<br>global scan matcher在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中</p><h3 id="A-优化问题"><a href="#A-优化问题" class="headerlink" title="A. 优化问题"></a>A. 优化问题</h3><p><code>闭环优化</code>，和<code>Scan match</code>一样，也被称为<code>非线性最小二乘问题</code>，它允许轻松添加残差以考虑其他数据。<br>每隔几秒钟，我们使用Ceres [14]来计算解决方案</p><script type="math/tex; mode=display">\underset{\Xi ^m,\Xi ^n}{argmin} \frac{1}{2}\sum _{ij}\rho (E^2(\xi _i^m,\xi _j^s;\sigma _{ij},\xi _{ij}))\tag{SPA}</script><p>在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。<br>这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。<br>对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。<br>协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。<br>这种约束的残差E由下式计算</p><script type="math/tex; mode=display">E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4</script><script type="math/tex; mode=display">e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - \left(     \begin{matrix}     R_{\xi_i^m}^{-1}(t_{\xi_i^m}-t_{\xi_j^s}) \\    \xi_{ij} - \xi_{j;\theta}^s    \end{matrix}\right).\tag5</script><p>损失函数$\rho$，例如<code>Huber loss</code>，用于减少当<code>Scan match</code>为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。<br>例如，这可能发生在局部对称环境中，例如办公室隔间。<br>异常值的替代方法包括[16]。</p><h3 id="B-Branch-and-bound-scan-match"><a href="#B-Branch-and-bound-scan-match" class="headerlink" title="B. Branch-and-bound scan match"></a>B. Branch-and-bound scan match</h3><p>我们对最佳的<code>像素精确匹配</code>感兴趣</p><script type="math/tex; mode=display">\xi^* = \underset{\xi\in\omega}{argmax}\sum_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}</script><p>其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。</p><p>通过仔细选择步长来提高效率。<br>我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。<br>我们推导出使用余弦定律</p><script type="math/tex; mode=display">d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\</script><script type="math/tex; mode=display">\xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7</script><p>我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30\degree$</p><script type="math/tex; mode=display">w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W_\theta}{\xi_\theta}\rceil.\tag8</script><p>这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口，</p><script type="math/tex; mode=display">\overline{W} = \{-w_x,...,w_x\} \times \{-w_y,...,w_y\} \times \{-w_\theta,...,w_\theta\}\tag9</script><script type="math/tex; mode=display">W = \{\xi_0 + (rj_x, rj_y, \xi_\theta j_\theta):(j_x,j_y,j_\theta) \in \overline{W}\}\tag{10}</script><p>找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。</p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo1.png?raw=true" alt="image"></p><p>相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。<br>有关通用方法，请参见算法2。<br>    这种方法最初是在混合整数线性程序的背景下提出的[17]。<br>关于这个主题的文献很广泛; 见[18]简短概述。<br>主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。<br>每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。<br>叶节点是单体; 每个代表一个可行的解决方案。<br>请注意，算法是准确的。<br>只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。<br>在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。</p><p>为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。</p><h4 id="1-节点选择"><a href="#1-节点选择" class="headerlink" title="1) 节点选择:"></a>1) 节点选择:</h4><p>在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。<br>这取决于两件事：良好的上限和良好的当前解决方案。<br>后一部分由DFS帮助，它可以快速评估许多叶节点。<br>由于我们不希望将不良匹配作为<code>闭环</code>约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。<br>由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。<br>关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。<br>算法3是这种方法。</p><h4 id="2-分支规则："><a href="#2-分支规则：" class="headerlink" title="2) 分支规则："></a>2) 分支规则：</h4><p>树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。<br>高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换：</p><script type="math/tex; mode=display">\overline {\overline{W}} = \Bigg(\{j_x,j_y\} \in \Bbb{Z}^2:  \\\Big\lbrace\begin{array}{l}        c_x \leq j_x < c_x + 2^{ch} \\        c_x \leq j_x < c_x + 2^{ch}        \end{array}\Big\rbrace        \times \lbrace c_\theta \rbrace \Bigg) ,\tag{11}</script><script type="math/tex; mode=display">\overline{W}_c = \overline{\overline{W}} \cap \overline{W}\tag{12}</script><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo2.png?raw=true" alt="image"></p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo3.png?raw=true" alt="image"></p><p>叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。</p><p>在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口</p><script type="math/tex; mode=display">\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\C_0 = \overline{W}_{0,x} \times \overline{W}_{0,y} \times \overline{W}_{0,\theta} \times \{h_0\}. \tag{13}</script><p>At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$<br>在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$</p><script type="math/tex; mode=display">C_c = ((\{c_x,c_x + 2^{c_h-1}\} \times {c_y, c_y + 2^{c_h-1} \times c_\theta}) \cap \overline{W}) \times \{c_h-1\}\tag{14}</script><h4 id="3-计算上界："><a href="#3-计算上界：" class="headerlink" title="3) 计算上界："></a>3) 计算上界：</h4><p>分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。<br>我们用</p><script type="math/tex; mode=display">score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\\geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M_{nearest}(T\xi_{j}h_{k})\\\underset{j\in \overline{W_c}}{max}\sum_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k})\tag{15}</script><p>为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。<br>每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。<br>请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。</p><script type="math/tex; mode=display">score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16}</script><script type="math/tex; mode=display">M_{precomp}^{ch}(x,y) =      \underset    {\begin{matrix}        x^, \in [x,x+r(2^h-1)] \\        y^, \in [y,y+r(2^h-1)]    \end{matrix}}    {max}M_{nearest}(x^, , y^,) \tag{17}</script><p>与叶节点一样使用$\xi_c$。<br>请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。<br>图3给出了这种预先计算的网格的一个例子。</p><p>为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。<br>然后我们计算一组预先计算的网格，并开始匹配它。</p><p>对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。<br>使用该中间结果，然后构造下一个预先计算的网格。</p><p>如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。<br>连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。<br>对于空的值集合，此列表为空。<br>使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。</p><p>计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。<br>由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] E. Olson，<code>M3RSM：多对多分辨率Scan match</code>，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。</p><p>[2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，<code>`稀疏位姿调整</code>2D绘图`，在IROS，台湾台北，2010年10月10日。</p><p>[3] F. Lu和E. Milios，<code>用于环境绘图的全局一致范围扫描对准</code>，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。</p><p>[4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，<code>两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测</code>，Robotica，vol。 32，不。 01，pp.19-41,2014。</p><p>[5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，<code>具有完整3D运动估计的灵活且可扩展的SLAM系统</code>，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。</p><p>[6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，<code>使用几何地标关系的2D LIDAR扫描中的大规模地点识别</code>，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。</p><p>[7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，<code>学习close闭合范围数据循环</code>，<code>国际机器人研究杂志</code>，第一卷。 30，不。 14，pp.1728-1754,2011。</p><p>[8] G. Grisetti，C。Stachniss和W. Burgard，<code>通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器</code>，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。</p><p>[9] G. D. Tipaldi，M。Braun和K. O. Arras，<code>FLIRT：2D范围数据的兴趣区域，应用于机器人导航</code>，在实验机器人中。 Springer，2014年，第695-710页。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer 论文翻译&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms-notes</title>
    <link href="http://lsy563193.github.io/algorithms-notes/"/>
    <id>http://lsy563193.github.io/algorithms-notes/</id>
    <published>2018-07-31T01:22:51.000Z</published>
    <updated>2018-11-06T04:29:06.044Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithms-notes</p><p>Algorithms-notes<br>Algorithms-notes<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithms-notes&lt;/p&gt;
&lt;p&gt;Algorithms-notes&lt;br&gt;Algorithms-notes&lt;br&gt;
    
    </summary>
    
      <category term="算法相关" scheme="http://lsy563193.github.io/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="algo" scheme="http://lsy563193.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>静脉曲张的原理和治疗方法</title>
    <link href="http://lsy563193.github.io/health-VaricoseVeins/"/>
    <id>http://lsy563193.github.io/health-VaricoseVeins/</id>
    <published>2018-07-30T03:25:06.000Z</published>
    <updated>2018-11-19T10:03:28.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>静脉曲张形成的主要原因是由于<strong>先天性血管壁膜</strong>比较薄弱或长时间维持相同姿势很少改变，<strong>血液蓄积下肢</strong>，在日积月累的情况下<strong>破坏静脉瓣膜</strong>而产生<strong>静脉压过高</strong>，使血管突出皮肤表面的症状。<br><a id="more"></a></p><h2 id="改善方法"><a href="#改善方法" class="headerlink" title="改善方法"></a>改善方法</h2><h3 id="物理治疗-弹力袜"><a href="#物理治疗-弹力袜" class="headerlink" title="物理治疗: 弹力袜"></a><strong>物理治疗: 弹力袜</strong></h3><p>1.1 <strong>弹力袜促进血液回流</strong>: 为什么有用?: 弹力袜在腿上的压力不一样，利用这种压力梯度可以促进血液回流。</p><blockquote><p><strong>注意</strong>：　但不是所有的人都适合穿弹力袜，静脉曲张较严重的患者穿弹力袜之前最好咨询医生。</p></blockquote><p>1.2 <strong>按摩加速血液循环</strong>:<br>在腿部感到疲劳时，或者平时方便的时候对腿部进行简单的揉捏，加速血液循环。</p><blockquote><p><strong>注意</strong>：坚持下来，静脉曲张就可以得到有效的改善.<br>至于按摩可以改善血液循环的原理其实并不是很有科学依据，知乎上还是能找到一些,<br>但是找不到靠谱的解释，本人实践过，确实是没有什么改善,不过也有可能是按摩手法的不对。<br>网上找了能够促进血液循环的按摩方法.<br><a href="https://www.youtube.com/watch?v=TcDrua76qDo" target="_blank" rel="noopener"><strong>静脉曲张按摩手法</strong></a></p></blockquote><h3 id="运动加强静脉管壁"><a href="#运动加强静脉管壁" class="headerlink" title="运动加强静脉管壁"></a><strong>运动加强静脉管壁</strong></h3><p>从血液动力学的角度进行观察，健康的人在运动时，由于瓣膜的功能正常，肌肉的规律性收缩使得深部静脉血液回流加速，皮下静脉的压力甚至可能比静止时还低。所以进行适当的跑步锻炼，不但不会引起下肢静脉曲张，恰恰相反，跑步可以使腿部肌肉活动增强，挤压静脉内的血液，使其流动更加顺畅，还有助于预防和改善下肢静脉曲张。对于静脉曲张的患者来说，当然也可以进行如<strong>慢跑、游泳、单车、跳绳</strong>等运动。但是因为静脉瓣膜功能受损，应当避免像举重、快速冲刺短跑、跳远、投掷等引起腹压增高的活动。</p><blockquote><p><strong>注意</strong>:但是严重的静脉曲张患者，不要一下子运动过量，否则容易对心血管造成伤害。</p></blockquote><h3 id="食疗"><a href="#食疗" class="headerlink" title="食疗"></a><strong>食疗</strong></h3><p>　　多食用蔬菜、水果、豆类等纤维素含量较高的食物，适量食用瘦牛肉、鸡肉等，多吃含维E的食物，如洋白菜、菠菜、橙子等可以<strong>疏通经络，改善血液循环</strong>，减轻腿部的沉重感。</p><blockquote><p>1、在静脉曲张的饮食中新鲜蔬菜和水果不能少：新鲜蔬菜和水果含有大量的维生素及矿物质，可以改善组织的氧化作用，增加血液循环，提高机体免疫力。如新鲜水果中含有大量维生素 C ，可以通过降低血凝倾向，改善血液循环，促进康复，预防淤伤。新鲜蔬菜含有丰富纤维素，能避免便秘，保持肠道清洁，改善肛周围的血液循环，预防末梢静脉曲张和痔疮的形成。</p><p>2、要有足够的蛋白质：静脉曲张的饮食中要多含蛋白质丰富的食物，如鱼、牛、羊肉等，大豆以及豆制品也含有丰富的植物蛋白，也应多吃。充足的蛋白质可以维持体内所有营养物质的平衡，增强免疫力，保护细胞，还可以乳化脂肪，促进血液循环。</p><p>3、含维生素 E 丰富的食物：静脉曲张的饮食要多含维生素E的食物，可以改善血液循环，减轻腿部的沉重感。含维生素 E 丰富的食物有：洋白菜、菠菜、甘蓝、麦芽、坚果类、大豆、全麦、粗粮、蛋等都是静脉曲张的饮食注意事项。</p></blockquote><h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>预防的扎6招防小腿静脉曲张 睡前抬腿久站抬脚尖</p><h3 id="1-睡前抬腿"><a href="#1-睡前抬腿" class="headerlink" title="1. 睡前抬腿"></a>1. 睡前抬腿</h3><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-taijiao.jpg" alt="静脉曲张抬脚"></p><h3 id="2-久站抬脚尖"><a href="#2-久站抬脚尖" class="headerlink" title="2. 久站抬脚尖"></a>2. 久站抬脚尖</h3><p>静脉曲张的成因是静脉瓣膜功能不良，静脉血液向下逆流而形成静脉曲张。因此，站立时，要每隔一段时间就抬脚尖，让肌肉收缩，给静脉血液加压，让血液往心脏方向流动，致使静脉瓣膜打开维持正常功能。一般来说，小腿感到酸麻时，就是在提醒你要抬脚尖了。</p><h3 id="3-穿平跟鞋"><a href="#3-穿平跟鞋" class="headerlink" title="3. 穿平跟鞋"></a>3. 穿平跟鞋</h3><p>平跟鞋有助于预防静脉曲张，在体育锻炼时一定要穿有海绵垫的运动鞋或旅游鞋，对缓解腿部压力，预防静脉曲张很有帮助。</p><h3 id="4-赤足"><a href="#4-赤足" class="headerlink" title="4. 赤足"></a>4. 赤足</h3><p>在条件允许的情况下，下班回家后，将鞋脱掉，赤足或穿拖鞋行走，可以改善足部血液循环，并使足部肌肉得到锻炼。</p><h3 id="5-抬高下肢"><a href="#5-抬高下肢" class="headerlink" title="5. 抬高下肢"></a>5. 抬高下肢</h3><p>站立工作者在工间休息时，宜将鞋脱掉，双脚抬高，足部要高于心脏30厘米以上，下班回到家中后也应将双脚抬高15分钟，缓解血液对下肢的压力。</p><h3 id="6-改掉不良如厕习惯"><a href="#6-改掉不良如厕习惯" class="headerlink" title="6. 改掉不良如厕习惯"></a>6. 改掉不良如厕习惯</h3><p>在上厕所时看书报，这是很不好的生活习惯。上厕所时看书报，蹲踞时间长会给下肢静脉增加过多的负担，造成血管内滞血，因此这种习惯一定要改掉。</p><h2 id="装备"><a href="#装备" class="headerlink" title="装备:"></a>装备:</h2><h3 id="1-弹力袜子"><a href="#1-弹力袜子" class="headerlink" title="1. 弹力袜子"></a>1. 弹力袜子</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>起床穿。 睡觉不穿。 半年换。最好三个月，看物料和生活习惯。因为弹性会不断下降，没弹性等于没压力，所以穿鬆了就要换。</li><li>手洗＋不晒太阳＋摊乾＋不用化学清洗剂(柔顺／漂白)可以让弹性保持久一点，这个就看自己勤不勤快了。</li><li>最重要的一点，运动。简单说就是让下肢肌肉更好的泵血，更好的把血从下肢输送回心脏，另外也可以避免和减少长期穿压力袜后依赖和股肉无力的情况。</li></ul><h4 id="选择型号"><a href="#选择型号" class="headerlink" title="选择型号"></a>选择型号</h4><ol><li>根据穿者的腿部症状选择合适的静脉曲张袜压力。<br>静脉曲张袜分为以下几级压力：<br>一级低压预防保健型(15-25mmHg)：适用于静脉曲张、血栓高发人群的保健预防;一级中压初期治疗型(25-30mmHg)：适用于静脉曲张初期患者;<br>二级高压中度治疗型(30-40mmHg)：适用于下肢已经有明显的静脉曲张(站立时静脉血管凸出皮肤表面)，并伴有腿部不适感的患者(如下肢酸乏肿胀、湿疹瘙痒、抽筋发麻、色素沉着等)、静脉炎、怀孕期间严重静脉曲张、静脉曲张手术后(大小隐静脉剥脱术)患者、深静脉血栓形成后综合症患者;<br>三级高压重度治疗型(40-50mmHg)：适用于下肢高度肿胀、溃疡、皮肤变黑变硬、高度淋巴水肿、整形抽脂术后恢复期等患者。</li><li>根据病变部位选择静脉曲张袜的长度。中统袜(膝下)、长统袜(及大腿)、连裤袜(及腰部)。如果穿者只是膝盖以下的部位患有静脉曲张，穿中统静脉曲张袜即可;如果穿者膝盖以上的部位也有症状、需要穿长统的或者连裤型静脉曲张袜。</li><li>确定合适的号型(静脉曲张袜分为小号S、中号M、大号L、加大号XL)。量出穿者腿部的三个主要尺寸(厘米)：脚踝(脚脖子最细处)周长、小腿肚最大周长及大腿最大周长，以确定合适的号码，购买连裤袜要根据穿者的身高体重选择号码。<blockquote><p><strong>注意</strong>: 如何判断自己的静脉曲张严重程度<br>国际上，静脉曲张按照程度不同共分为0-6期：</p></blockquote></li></ol><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-%E4%B8%A5%E9%87%8D%E7%A8%8B%E5%BA%A6%E5%88%A4%E5%88%AB.jpeg" alt="静脉曲张临床六期图谱表现"></p><p><strong>c1</strong>: 表层血管像蚯蚓一样曲张，明显凸出皮肤，曲张呈团状或结节状，有毛细血管扩张、网状静脉、踝部潮红。<br><strong>c2</strong>: 在站立时腿部可见弯曲增粗的表浅静脉血管，高出皮肤，在腿部抬高或平卧后可消失，常有小腿酸胀、易疲劳等不适感觉，此期是治疗的较好时期。<br><strong>c3</strong>: 曲张血管增多，小腿开始出现水肿，以站立过久或劳累后较明显，晨起时水肿可消退。患肢常比对侧腿增粗，有些人还出现皮肤瘙痒，严重者呈现湿疹、瘀积性皮炎等皮肤病变。<br><strong>c4</strong>: 血管内血液瘀积过多，静脉压力明显增高，使一部分血液成分渗透至血管外的皮肤及皮下组织，造成局部皮肤发红，变紫，直至发黑(血中铁元素沉积)，并且失去弹性而变硬。<br><strong>c5</strong>: 已发展为急性溃疡期，发黑变硬的皮肤在外力作用下发生破溃，采用普通方法已很难康复，严重影响工作与生活。<br><strong>c6</strong>: 静脉曲张晚期，或未经正确治疗的静脉性溃疡反复发作，形成臁疮腿，常见于踝关节附近及小腿下段，俗称“老烂腿”。</p><ol><li>一级压力裤: c1</li><li>二级压力裤: c2-c4</li><li>三级压力裤: c4*c6</li></ol><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-%E9%80%82%E5%90%88%E7%9A%84%E5%8E%8B%E5%8A%9B%E8%A2%9C.png" alt="适合的压力袜子"></p><h4 id="去哪里买"><a href="#去哪里买" class="headerlink" title="去哪里买"></a>去哪里买</h4><ol><li><p>国内压力袜是属于医疗器械，不是哪都可以卖的，如果不是正规的地方卖的，大概率不是真的</p></li><li><p>上外国网站自己买，因为国内压力袜是属于医疗器械，如果有代购或是什麽海淘，如果不是正规的医疗器械卖家，性质像偷卖外国药一样。</p></li></ol><p><a href="https://www.jd.com/phb/1315308f5a70f12facfc.html" target="_blank" rel="noopener">排行版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;静脉曲张形成的主要原因是由于&lt;strong&gt;先天性血管壁膜&lt;/strong&gt;比较薄弱或长时间维持相同姿势很少改变，&lt;strong&gt;血液蓄积下肢&lt;/strong&gt;，在日积月累的情况下&lt;strong&gt;破坏静脉瓣膜&lt;/strong&gt;而产生&lt;strong&gt;静脉压过高&lt;/strong&gt;，使血管突出皮肤表面的症状。&lt;br&gt;
    
    </summary>
    
      <category term="运动康复" scheme="http://lsy563193.github.io/categories/%E8%BF%90%E5%8A%A8%E5%BA%B7%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>封闭阳台</title>
    <link href="http://lsy563193.github.io/homework-Closed-balcony/"/>
    <id>http://lsy563193.github.io/homework-Closed-balcony/</id>
    <published>2018-07-28T14:38:20.000Z</published>
    <updated>2018-11-19T05:28:18.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般封闭阳台由三部分构成</p><ul><li><strong>框窗</strong>:建议安装<code>有框</code> <code>气密窗</code>，最好是经过抗压性、气密性（刮风的时候不会有灰尘钻进来）和水密性（下雨的时候不会有水流到室内）检验的。</li></ul><blockquote><p>注意：　气密性能: 120等级、30等级、8等级、2等级<br>影响因素: 窗户框扇的搭接处、气密防水胶条和毛刷条长度、内扇窗的气密橡胶条与内扇下支长度，毛刷条的完整性，玻璃压条与玻璃长度</p></blockquote><ul><li><strong>玻璃</strong><blockquote><p>钢化玻璃<br>隔音保温表现更好的双层中空玻璃</p></blockquote></li><li><strong>防护栏</strong><a id="more"></a><h2 id="框窗"><a href="#框窗" class="headerlink" title="框窗"></a>框窗</h2></li></ul><p>框窗类型有很多，铝合金门窗、实木窗、铝木复合窗、玻璃钢门窗、不锈钢门窗、无框窗</p><ul><li><strong>塑钢门窗</strong><br>优点是隔音、隔热防火保温，气密性、水密、防腐都不错，而且价格便宜。缺点是它的断面较大，比起铝合金窗来说采光性略差。</li><li><p><strong>铝合金门窗</strong><br>优点: 硬度高，不易刮伤，耐磨耐候，表面光滑，耐污性佳便于清洁。而且价格便宜。<br>缺点: 是导热性强，保温性差。</p></li><li><p><strong>断桥铝合金</strong><br>优点:　结合上面两种<br>缺点:　最贵</p></li></ul><p>-<strong>玻璃门窗（也叫无框窗）</strong><br>优点:采光性良好、空气流通好、美观易折叠等。<br>缺点:保温性差，密封性差，隔音一般。</p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><h3 id="塑钢窗的价格"><a href="#塑钢窗的价格" class="headerlink" title="塑钢窗的价格"></a>塑钢窗的价格</h3><p>塑钢窗主材价格:每种品牌的塑钢窗主材价格不同,如海螺型材现在的价格是10500元/吨,每吨的出窗率要看窗的型号,88推拉窗估计能出95-100平米,80的推拉窗能出100-105平米,60平开窗能出70-75平米左右,按面积计算,也就是88的型材成本价格为110-105元,80的型材成本价格为105-100元,60的型材成本合到150-140元。</p><p>塑钢窗五金配件价格:推拉窗要用到的滑轮和月牙锁,这两个加起来的价格为8元/平米,还有就是密封毛条和减震胶条,加起来价格为10元/平米,再就是制作和安装要30元/平米,另外运输要4元/平米。</p><p>塑钢窗加强钢价格:主材里要有加强钢,市场价格是4000左右/吨,如果用的是1.2的话要成本20元左右,低于这个标准的1.0以下的可能有12元左右就可以了。</p><p>塑钢窗玻璃价格:市场上的玻璃有浮法、格法、平板等几种,浮法的5毫米的玻璃价格30元,格法的24元,平板的19元。如果用中空玻璃的话,除了加一层玻璃的钱还要用到铝合金的框架和干燥外围的中空胶,这些的成本价格是10-15元。</p><p>塑钢窗密封处理价格:主要是打泡沫胶和密封胶,价格要看窗台的平整情况,好的窗台有5元/米就可以,旧的窗台由于拆旧窗的破坏会用到12元/米左右。</p><p>88推拉窗 110 型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=212元/平米。</p><p>80推拉窗 105型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=207元/平米。</p><p>60平开窗 150型材+五38+配件10+制作安装30+20加强钢+玻璃30+运输4=284元/平米。</p><h3 id="铝合金窗的价格"><a href="#铝合金窗的价格" class="headerlink" title="铝合金窗的价格"></a>铝合金窗的价格</h3><p>铝合金普通推拉窗的价格在250元/平方米左右,采用1.2mm厚标准铝型材,单片5mm玻璃;铝合金隔音隔热窗750元/平方米左右,采用1.4厚铝型材,中空玻璃。</p><p>铝合金窗主材价格差别很大,铝材的价格主要差别在铝材的质量上,有厚薄优劣之分,一般氧化铝材160元/平米,电泳铝材200元/平方左右,彩色铝材260元/平米以上。铝型材质有50系列、55系列、60系列、70系列等,其中50系列的铝材价格在400元/平米左右,而70系列铝材价格可达到700元/平米,不同系列的铝材质厚度不一样,铝材越厚的窗户价格越高。</p><p>以上是塑钢窗和铝合金窗的价格介绍,塑钢窗因为用得比较多,大家对它的价格很熟悉。铝合金窗低档的没人愿意用,宁可用塑钢窗代替,高档铝合金窗价格又很高,常用于施工要求较高的建筑或高档建筑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一般封闭阳台由三部分构成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;框窗&lt;/strong&gt;:建议安装&lt;code&gt;有框&lt;/code&gt; &lt;code&gt;气密窗&lt;/code&gt;，最好是经过抗压性、气密性（刮风的时候不会有灰尘钻进来）和水密性（下雨的时候不会有水流到室内）检验的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：　气密性能: 120等级、30等级、8等级、2等级&lt;br&gt;影响因素: 窗户框扇的搭接处、气密防水胶条和毛刷条长度、内扇窗的气密橡胶条与内扇下支长度，毛刷条的完整性，玻璃压条与玻璃长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;玻璃&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;钢化玻璃&lt;br&gt;隔音保温表现更好的双层中空玻璃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防护栏&lt;/strong&gt;
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
      <category term="阳台" scheme="http://lsy563193.github.io/tags/%E9%98%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://lsy563193.github.io/language-python-notes/"/>
    <id>http://lsy563193.github.io/language-python-notes/</id>
    <published>2018-07-26T11:35:47.000Z</published>
    <updated>2018-11-06T04:28:54.531Z</updated>
    
    <content type="html"><![CDATA[<p>python笔记<br>python笔记python笔记<br>python笔记<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python笔记&lt;br&gt;python笔记python笔记&lt;br&gt;python笔记&lt;br&gt;
    
    </summary>
    
      <category term="语言相关" scheme="http://lsy563193.github.io/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="http://lsy563193.github.io/tags/python/"/>
    
  </entry>
  
</feed>
