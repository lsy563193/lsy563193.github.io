<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林少岳的博客</title>
  
  <subtitle>学而不思则罔 思而不学则殆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lsy563193.github.io/"/>
  <updated>2018-12-13T01:40:31.017Z</updated>
  <id>http://lsy563193.github.io/</id>
  
  <author>
    <name>ShaoYue Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cartographer论文翻译:二维建图的高效稀疏姿态调整</title>
    <link href="http://lsy563193.github.io/slam-EfficientSPAFor2DMapping/"/>
    <id>http://lsy563193.github.io/slam-EfficientSPAFor2DMapping/</id>
    <published>2018-11-27T03:03:04.000Z</published>
    <updated>2018-12-13T01:40:31.017Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer 论文翻译<br><a id="more"></a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>姿势图已成为解决同时定位和建图（SLAM）问题的流行表示。<br>姿势图是一组机器人姿势，通过观察附近姿势共有的特征获得的非线性约束连接。<br>优化大型姿势图一直是移动机器人的瓶颈，因为直接非线性优化的计算时间可以随着图的大小而立方增长。<br>在本文中，我们提出了一种构造和求解线性子问题的有效方法，这是这些直接方法的瓶颈。<br>我们将我们称为稀疏姿态调整（SPA）的方法与竞争间接方法进行比较，并表明它在收敛速度和准确性方面优于它们。<br>我们在大量室内真实世界地图和非常大的模拟数据集上展示了它的有效性。<br>C++中的开源实现和数据集是公开可用的。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>The recent literature in robot mapping shows an increasing interest in graph-based SLAM approaches.<br>In the most general form, the graph has nodes that represent both robot poses and world features, with measurements connecting them as constraints.<br>The goal of all approaches is to jointly optimize the poses of the nodes so as to minimize the error introduced by the constraint.<br>One classical variant of this problem comes from computer vision and is denoted as Bundle Adjustment [25], which is typically solved with a specialized variant of the Levenberg-Marquardt (LM) nonlinear optimizer.<br>In the SLAM literature, Lu-Milios [18], GraphSLAM [24], and √ SAM [4] are all variants of this technique.<br>机器人建图的最新文献显示出对基于图的SLAM方法的兴趣日益增加。<br>在最一般的形式中，图形具有表示机器人姿势和世界特征的节点，测量将它们连接为约束。<br>所有方法的目标是联合优化节点的姿势，以便最小化约束引入的误差。<br>该问题的一个经典变体来自计算机视觉，并表示为束调整[25]，其通常用Levenberg-Marquardt（LM）非线性优化器的专用变体解决。<br>在SLAM文献中，Lu-Milios [18]，GraphSLAM [24]和√SAM[4]都是这种技术的变种。 </p><p>Since features tend to outnumber robot poses,<br>more compact systems can be created by converting observations of features into direct constraints among the robot poses,<br>either by marginalization [1, 24, 4], or by direct matching – for example,<br>matching laser scans between two robot poses yields a relative pose estimate for the two.<br>Pose constraint systems, in typical robotic mapping applications, exhibit a sparse structure of connections,<br>since the range of the sensor is typically limited to the vicinity of the robot.<br>由于功能往往超过机器人姿势，<br>通过将特征观察转换为机器人姿势之间的直接约束，可以创建更紧凑的系统，<br>要么通过边缘化[1,24,4]，要么通过直接匹配 - 例如，<br>在两个机器人姿势之间匹配激光扫描产生两者的相对姿势估计。<br>在典型的机器人地图应用中，姿态约束系统表现出稀疏的连接结构，<br>因为传感器的范围通常限于机器人的附近。</p><p>Solving pose graphs efficiently (i.e., finding the optimal positions of the nodes) is a key problem for these methods especially in the context of online mapping problems.<br>A typical 2D laser map for a 100m x 100m office space may have several thousand nodes and many more constraints (see Figure 1).<br>Furthermore, adding a loop closure constraint to this map can affect almost all of the poses in the system.<br>有效地解决姿势图（即，找到节点的最佳位置）是这些方法的关键问题，尤其是在在线建图问题的背景下。<br>100m x 100m办公空间的典型2D激光地图可能有数千个节点和更多约束（见图1）。<br>此外，向此建图添加循环闭包约束可能会影响系统中的几乎所有姿势。</p><p><img src="_posts/slam-cartographer-notes/Screenshot\ from\ 2018-11-29\ 10-21-01.png" alt="image"></p><p>At the heart of the LM method lies the solution of a large sparse linear problem.<br>In this paper, we develop a method to efficiently compute the sparse matrix from the constraint graph, and use direct sparse linear methods to solve it.<br>In analogy to Sparse Bundle Adjustment in the vision literature, we call this method Sparse Pose Adjustment (SPA), since it deals with the restricted case of pose-pose constraints.<br>The combination of an SBA/GraphSLAM optimizer with efficient methods for solving the linear subproblem has the following advantages.<br>LM方法的核心在于解决大的稀疏线性问题。<br>在本文中，我们开发了一种从约束图有效地计算稀疏矩阵的方法，并使用直接稀疏线性方法来解决它。<br>与视觉文献中的稀疏束调整类似，我们将此方法称为稀疏姿势调整（SPA），因为它处理姿势 - 姿势约束的受限情况。<br>SBA / GraphSLAM优化器与解决线性子问题的有效方法的组合具有以下优点。</p><p>It takes the covariance information in the constraints into account which leads to more accurate solutions.<br>• SPA is robust and tolerant to initialization, with very low failure rates (getting stuck in local minima) for both incremental and batch processing.<br>• Convergence is very fast as it requires only a few iterations of the LM method.<br>• Unlike EKF and information filters, SPA is fully nonlinear: at every iteration, it linearizes all constraints around their current pose.<br>• SPA is efficient in both batch and incremental mode<br>它考虑约束中的协方差信息，从而得到更精确的解。</p><p>●SPA是健壮的并且容忍初始化，对于增量处理和批处理来说，具有非常低的故障率（陷入局部最小值）。</p><p>●收敛非常快，因为它只需要LM方法的几次迭代。</p><p>●与EKF和信息滤波器不同，SPA是完全非线性的：在每次迭代中，它线性化当前姿态周围的所有约束。</p><p>SPA在批处理和增量模式下都是有效的</p><p>We document these and other features of the method in the experimental results section where we also compare our method to other LM and non-LM state-of-the-art optimizers.<br>我们在实验结果部分记录了该方法的这些和其他特征，其中我们还将此方法与其他LM和非LM的最新优化器进行比较。</p><p>One of the benefits of the efficiency of SPA is that a mapping system can continuously optimize its graph, providing the best global estimate of all nodes, with very little computational overhead.<br>Solving the optimization problem for the large map shown in Figure 1 requires only 150 ms from an initial configuration provided by odometry.<br>In the incremental mode, where the graph is optimized after each node is added, it requires less than 15 ms for any node addition.<br>SPA效率的好处之一是，映射系统可以连续优化其图，提供所有节点的最佳全局估计，而计算开销非常小。</p><p>解决图1所示的大型地图的优化问题只需要距离里程计提供的初始配置150ms。</p><p>在增量模式下，在添加每个节点之后优化图，对于任何节点添加，它需要小于15ms。</p><p>Although SPA can be parameterized with 3D poses, for this paper we have restricted it to 2D mapping, which is a well-developed field with several competing optimization techniques.<br>Our intent is to show that a 2D pose-based mapping system can operate on-line using SPA as its optimization engine, even in large-scale environments and with large loop closures, without resorting to submaps or complicated partitioning schemes.<br>Although SPA can be parameterized with 3D poses, for this paper we have restricted it to 2D mapping, which is a well-developed field with several competing optimization techniques.<br>Our intent is to show that a 2D pose-based mapping system can operate on-line using SPA as its optimization engine, even in large-scale environments and with large loop closures, without resorting to submaps or complicated partitioning schemes.<br>Although SPA can be parameterized with 3D poses, for this paper we have restricted it to 2D mapping, which is a well-developed field with several competing optimization techniques.<br>Our intent is to show that a 2D pose-based mapping system can operate on-line using SPA as its optimization engine, even in large-scale environments and with large loop closures, without resorting to submaps or complicated partitioning schemes.</p><p>尽管SPA可以用3D姿态参数化，但是本文将其局限于二维映射，这是一个具有多种竞争优化技术的成熟领域。<br>我们的意图是表明一个基于二维姿态的映射系统可以在线使用SPA作为其优化引擎，甚至在大规模环境和具有大环路闭合，而不诉诸子映射或复杂的划分方案。</p><h2 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h2><p>Lu and Milios [18] presented the seminal work on graphbased SLAM, where they determine the pairwise measurements between scans via ICP scan-matching and then optimize the graph by iterative linearization.<br>At that time, efficient optimization algorithms were not available to the SLAM community and graph-based approaches were regarded as too time-consuming.<br>Despite this, the intuitive formulation of graph-based SLAM attracted many researchers with valuable contributions.<br>Gutmann and Konolige [12] proposed an effective way for constructing such a network and for detecting loop closures while running an incremental estimation algorithm.</p><p>Lu和Milios[18]提出了基于图的SLAM的具有开创性的工作，其中他们通过ICP扫描匹配来确定扫描之间的成对测量，然后通过迭代线性化来优化该图。</p><p>那时，SLAM社区还没有有效的优化算法，基于图的方法被认为太耗时。</p><p>尽管如此，基于图的SLAM的直观公式吸引了许多研究者，并做出了有价值的贡献。</p><p>Gutmann和Konolige[12]提出了一种构造这种网络和在运行增量估计算法的同时检测环路闭合的有效方法。</p><p>Since the Lu and Milios paper, many approaches for graph optimization have been proposed.<br>Howard et al. [13] apply relaxation to localize the robot and build a map. Duckett et al. [6]<br>propose the usage of Gauss-Seidel relaxation to minimize the error in the network of constraints.<br>To overcome the inherently slow convergence of relaxation methods, Frese et al. [9] propose a variant of Gauss-Seidel relaxation called multi-level relaxation (MLR).<br>It applies relaxation at different resolutions.<br>MLR is reported to provide very good results in 2D environments, especially if the error in the initial guess is limited.</p><p>自从Lu和Milios论文发表以来，人们提出了许多图优化的方法。</p><p>霍华德等人。〔13〕应用松弛法定位机器人并建立地图。</p><p>杜克特等人。〔6〕 提出了利用高斯-塞德尔松弛来最小化约束网络中的误差。</p><p>为了克服松弛法固有的收敛速度慢，Frase等人。[9]提出了Gauss-Seidel弛豫的一种变型，称为多层弛豫(MLR)。</p><p>它适用于不同分辨率的放松。</p><p>据报道，MLR在2D环境中提供非常好的结果，尤其是在初始猜测的误差有限的情况下。</p><p>Olson et al. [21] proposed stochastic gradient descent to optimize pose graphs.<br>This approach has the advantage of being easy to implement and exceptionally robust to wrong initial guesses.<br>Later, Grisetti et al. [10] extended this approach by applying a tree based parameterization that significantly increases the convergence speed.<br>The main problem of these approaches is that they assume the error in the graph to be more or less uniform, and thus they are difficult to apply to graphs where some constraints are under-specified.</p><p>奥尔森等人提出了随机梯度下降法来优化姿态图。</p><p>这种方法的优点是易于实现，并且对错误的初始猜测异常健壮。</p><p>后来，格里塞蒂等。[10]通过应用显著提高收敛速度的基于树的参数化来扩展这种方法。</p><p>这些方法的主要问题是，它们假设图中的误差或多或少是均匀的，因此它们很难应用于某些约束未被指定的图。</p><p>The most intuitive way to optimize a graph is probably by nonlinear least-squares optimization, such as LM.<br>Leastsquares methods require to repetitively solve a large linear system obtained by linearizing the original likelihood function of the graph.<br>This linear system is usually very large; accordingly, the first graph-based approaches were time consuming, because they did not exploit its natural sparsity.<br>One promising technique is Preconditioned Conjugate Gradient (PCG) [2], which was later used by Konolige [15] and Montemerlo and Thrun [20] as an efficient solver for large sparse pose constraint systems; the preconditioner is typically incomplete Cholesky decomposition.<br>PCG is an iterative method, which in general requires n iterations to converge, where n is the number of variables in the graph.<br>We have implemented a sparse-matrix version of PCG from Sparselib++ and IML++ [5], and use this implementation for comparison experiments in this paper.</p><p>优化图的最直观的方法可能是通过非线性最小二乘优化，如LM。</p><p>最小二乘法需要重复求解通过线性化图的原始似然函数而获得的大型线性系统。</p><p>这种线性系统通常非常大；因此，第一种基于图的方法是耗时的，因为它们没有利用其自然的稀疏性。</p><p>一种有前途的技术是预条件共轭梯度（PCG）[2]，后来被Konolige[15]和Montemerlo和Srun[20]用作大型稀疏位姿约束系统的有效求解器； 预条件通常是不完全Cholesky分解。</p><p>PCG是一种迭代方法，一般需要n次迭代才能收敛，其中n是图中变量的数目。</p><p>我们从Sparselib++和IML++[5]中实现了PCG的稀疏矩阵版本，并将该实现用于比较实验。</p><p>More recently, Dellaert and colleagues use bundle adjustment, which they implement using sparse direct linear solvers [3]; they call their system √ SAM [4]).<br>Our approach is similar to SAM; we differ from their approach mostly in engineering, by efficient construction of the linear subproblem using ordered data structures.<br>We also use LM instead of a standard nonlinear least-square method, thereby increasing robustness.<br>Finally, we introduce a “continuable LM” method for the incremental case, and an initialization method that is a much more robust approach to the batch problem.</p><p>最近，Dellaert和他的同事使用束调整，他们使用稀疏的直接线性求解器[3]实现束调整；他们称他们的系统_SAM[4]。</p><p>我们的方法与SAM类似；我们与他们的方法在工程上主要不同，这是通过使用有序数据结构高效地构造线性子问题。</p><p>我们还使用LM代替标准的非线性最小二乘法，从而提高了鲁棒性。</p><p>最后，我们介绍了增量情况下的一种“连续LM”方法，以及一种更稳健的批处理问题的初始化方法。</p><p>Kaess et al. [14] introduced a variant of √ SAM, called iSAM, that performs incremental update of the linear matrix associated with the nonlinear least-squares problem.<br>Relinearization and variable ordering are performed only occasionally, thereby increasing computational efficiency.<br>In our approach, relinearization and matrix construction are very efficient, so such methods become less necessary.<br>Currently we do not have an implementation of either iSAM or √ SAM to test against for performance.</p><p>凯斯等人。[14]引入了_SAM的变体，称为iSAM，其执行与非线性最小二乘问题相关联的线性矩阵的增量更新。</p><p>只偶尔执行重线性化和变量排序，从而提高计算效率。</p><p>在我们的方法中，重新线性化和矩阵构造是非常有效的，因此这些方法变得不太必要。</p><p>目前，我们没有iSAM或_SAM的实现，无法针对性能进行测试。</p><p>Relaxation or least-squares approaches proceed by iteratively refining an initial guess.<br>Conversely, approaches based on stochastic gradient descent are more robust to the initial guess.<br>In the SLAM literature the importance of this initial guess has been often underestimated.<br>The better the initial guess is, the more likely it is for an algorithm to find the correct solution.<br>In this paper, we address this point and evaluate three different strategies for computing the initial guess.</p><p>松弛法或最小二乘法通过迭代地细化初始猜测来进行。</p><p>相反，基于随机梯度下降的方法对初始猜测更稳健。</p><p>在SLAM文献中，这种初始猜测的重要性经常被低估。</p><p>初始猜测越好，算法找到正确解决方案的可能性就越大。</p><p>在本文中，我们讨论了这一点，并评估了三种不同的策略来计算初始猜测。</p><p>In contrast to full nonlinear optimization, several researchers have explored filtering techniques to solve the graphs incrementally, using an information matrix form.<br>The first such approach was proposed by Eustice et al.<br>and denoted Delayed Sparse Information Filter (DSIF) [7].<br>This technique can be very efficient, because it adds only a small constant number of elements to the system information matrix, even for loop closures.<br>However, recovering the global pose of all nodes requires solving a large sparse linear system; there are faster ways of getting approximate recent poses.</p><p>与全非线性优化相比，一些研究人员探索了使用信息矩阵形式递增地求解图的滤波技术。</p><p>第一种这样的方法是由EuStruts等人提出的。</p><p>并表示延迟稀疏信息滤波器（DSIF）〔7〕。</p><p>这种技术可能是非常有效的，因为它仅向系统信息矩阵添加少量的常数元素，甚至对于循环闭合也是如此。</p><p>然而，恢复所有节点的全局姿态需要求解一个大型的稀疏线性系统；有更快的方法来获得近似的最近姿态。</p><p>Frese proposed the TreeMap [8] algorithm that captures the sparse structure of the system by a tree representation.<br>Each leaf in the tree is a local map and the consistency of the estimate is achieved by sending updates to the local maps through the tree.<br>Under ideal conditions, this approach can update the whole map in O(n log n) time, where n is the numbers of elements in the map.<br>However, if the map has many local connections the size of the local maps can be very large and their updates (which are regarded as elementary operations) become computationally expensive as shown in the remainder of this paper.</p><p>Frese提出了TreeMap [8]算法，该算法通过树表示来捕获系统的稀疏结构。<br>树中的每个叶子都是一个本地地图，估计的一致性是通过树发送更新到本地地图来实现的。<br>在理想条件下，此方法可以在O（n log n）时间内更新整个地图，其中n是地图中元素的数量。<br>但是，如果地图具有许多本地连接，则本地地图的大小可能非常大，并且它们的更新（被视为基本操作）变得计算成本昂贵，如本文其余部分所示。</p><p>To summarize the paper: we propose an efficient approach for optimizing 2D pose graphs that uses direct sparse Cholesky decomposition to solve the linear system.<br>The linear system is computed in a memory-efficient way that minimizes cache misses and thus significantly improves the performance.<br>We compare our method, in both accuracy and speed, to existing LM and non-LM approaches that are avaiable, and show that SPA outperforms them.<br>Open source implementations are available both in C++ and in matlab/octave.<br>Efficient direct (non-iterative) algorithms to solve sparse systems have become available [3], thus reviving a series of approaches for optimizing the graphs which have been discarded in the past.<br>In this paper,<br>综上所述，本文提出了一种利用直接稀疏Cholesky分解求解线性系统的二维位姿图优化方法。</p><p>线性系统的计算采用内存高效的方式，使缓存遗漏最小化，从而显著提高了性能。</p><p>我们将我们的方法在精度和速度上与可用的现有LM和非LM方法进行比较，并且表明SPA优于它们。</p><p>开源实现在C++和Matlab/OcthVE中都是可用的。</p><p>用于求解稀疏系统的有效直接（非迭代）算法已经变得可用[3]，从而恢复了一系列用于优化过去被丢弃的图的方法。</p><p>在本文中，</p><p>III. SYSTEM FORMULATION</p><p>Popular approaches to solve the SLAM problem are the socalled “graph-based” or “network-based” methods.<br>The idea is to represent the history of the robot measurements by a graph.<br>Every node of the graph represents a sensor measurement or a local map and it is labeled with the location at which the measurement was taken.<br>An edge between two nodes encodes the spatial information arising from the alignment of the connected measurements and can be regarded as a spatial constraint between the two nodes.</p><p>Popular approaches to solve the SLAM problem are the socalled “graph-based” or “network-based” methods.<br>The idea is to represent the history of the robot measurements by a graph.<br>Every node of the graph represents a sensor measurement or a local map and it is labeled with the location at which the measurement was taken.<br>An edge between two nodes encodes the spatial information arising from the alignment of the connected measurements and can be regarded as a spatial constraint between the two nodes.<br>Popular approaches to solve the SLAM problem are the socalled “graph-based” or “network-based” methods.<br>The idea is to represent the history of the robot measurements by a graph.<br>Every node of the graph represents a sensor measurement or a local map and it is labeled with the location at which the measurement was taken.<br>An edge between two nodes encodes the spatial information arising from the alignment of the connected measurements and can be regarded as a spatial constraint between the two nodes.<br>解决SLAM问题的流行方法是所谓的“基于图”或“基于网络”方法。</p><p>这个想法是通过图表来表示机器人测量的历史。</p><p>图中的每个节点表示传感器测量或局部地图，并且用测量所处的位置对其进行标记。</p><p>两个节点之间的边缘编码由于连接测量的对齐而产生的空间信息，并且可以被视为两个节点之间的空间约束。</p><p>In the context of graph-based SLAM, one typically considers two different problems.<br>The first one is to identify the constraints based on sensor data.<br>This so-called data association problem is typically hard due to potential ambiguities or symmetries in the environment.<br>A solution to this problem is often referred to as the SLAM front-end and it directly deals with the sensor data.<br>The second problem is to correct the poses of the robot to obtain a consistent map of the environment given the constraints.<br>This part of the approach is often referred to as the optimizer or the SLAM back-end.<br>Its task is to seek for a configuration of the nodes that maximizes the likelihood of the measurements encoded in the constraints.<br>An alternative view to this problem is given by the springmass model in physics.<br>In this view, the nodes are regarded as masses and the constraints as springs connected to the masses.<br>The minimal energy configuration of the springs and masses describes a solution to the mapping problem.</p><p>在基于图的SLAM环境中，通常考虑两个不同的问题。</p><p>第一种是基于传感器数据识别约束。</p><p>由于环境中的潜在模糊或对称性，这种所谓的数据关联问题通常很难解决。</p><p>这个问题的解决方案通常被称为SLAM前端，它直接处理传感器数据。</p><p>第二个问题是修正机器人的姿态，以获得给定约束环境的一致映射。</p><p>这种方法的这一部分通常被称为优化器或SLAM后端。</p><p>它的任务是寻找使约束中编码的测量的可能性最大化的节点的配置。</p><p>对这个问题的另一种观点是由物理学中的弹性模型给出的。</p><p>在这种观点中，节点被视为质量，而约束则被视为与质量相连的弹簧。</p><p>弹簧和质量的最小能量配置描述了映射问题的解决方案。</p><p>During its operation a graph-based SLAM system interleaves the execution of the front-end and of the back-end, as shown in Figure 2.<br>This is required because the front-end needs to operate on a partially optimized map to restrict the search about potential constraints.<br>The more accurate the current estimate is, the more robust the constraints generated by the front-end will be and the faster its operation.<br>Accordingly, the performance of the optimization algorithm, measured in terms of accuracy of the estimate and execution time, has a major impact on the overall mapping system.<br>在其操作期间，基于图的SLAM系统交错前端和后端的执行，如图2所示。</p><p>这是必需的，因为前端需要对部分优化的映射进行操作，以限制对潜在约束的搜索。</p><p>当前估计越精确，由前端生成的约束将越健壮，并且其操作也越快。</p><p>因此，从估计精度和执行时间方面衡量的优化算法的性能对整个映射系统有重要影响。</p><p>In this paper we describe in detail an efficient and compact optimization approach that operates on 2D graphs.<br>Our algorithm can be coupled with arbitrary front-ends that handle different kinds of sensors.<br>For clarity of presentation we shortly describe a front-end for laser data.<br>However, the general concepts can be straightforwardly applied to different sensors.<br>本文详细描述了一种高效紧凑的二维图优化方法。</p><p>我们的算法可以与处理不同类型传感器的任意前端耦合。</p><p>为了简洁的介绍，我们简短地描述了激光数据的前端。</p><p>然而，一般概念可以直接应用于不同的传感器。</p><p>IV. SPARSE POSE ADJUSTMENT</p><p>To optimize a set of poses and constraints, we use the wellknown Levenberg-Marquardt (LM) method as a framework, with particular implementations that make it efficient for the sparse systems encountered in 2D map building.<br>In analogy to the Sparse Bundle Adjustment of computer vision, which is a similarly efficient implementation of LM for cameras and features, we call our system Sparse Pose Adjustment (SPA).</p><p>为了优化一组姿态和约束，我们使用众所周知的Levenberg-Marquardt(LM)方法作为框架，并且使用特定的实现使其对于二维地图构建中遇到的稀疏系统有效。</p><p>类似于计算机视觉的稀疏束调整（Sparse Bundle.stment），它是用于相机和特征的LM的类似高效实现，我们称之为稀疏姿态调整（Sparse Pose.stment，SPA）。</p><p>A. Error Formulation</p><p>The variables of the system are the set of global poses c of the robot, parameterized by a translation and angle: $c_i = [t_i , θ_i ] = [x_i , y_i , θ_i ] ⊤$.<br>A constraint is a measurement of one node cj from another’s (ci) position.<br>The measured offset between ci and cj , in ci’s frame, is z¯ij , with precision matrix Λij (inverse of covariance).<br>For any actual poses of ci and cj , their offset can be calculated as </p><pre><code>h(ci , cj ) ≡  R⊤ i (tj − ti) θj − θi (1)</code></pre><p>Here Ri is the 2x2 rotation matrix of θi . h(ci , cj ) is called the measurement equation.<br>The error function associated with a constraint, and the total error, are</p><pre><code>eij ≡ z¯ij − h(ci , cj ) χ 2 (c, p) ≡ X ij e ⊤ ijΛij eij (2) </code></pre><p>Note that the angle parameter in h(ci , cj ) is not unique, since adding or subtracting 2π yields the same result.<br>Angle differences are always normalized to the interval (−π, π] when they occur.</p><p>B. Linear System<br>The optimal placement of c is found by minimizing the total error in Equation 2.<br>A standard method for solving this problem is Levenberg-Marquardt (LM), iterating a linearized solution around the current values of c.<br>The linear system is formed by stacking the variables c into a vector x, and the error functions into a vector e.<br>Then we define:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer 论文翻译&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>冰箱收纳</title>
    <link href="http://lsy563193.github.io/homework-Refrigerator%20storage/"/>
    <id>http://lsy563193.github.io/homework-Refrigerator storage/</id>
    <published>2018-11-19T00:55:31.000Z</published>
    <updated>2018-11-19T05:30:46.159Z</updated>
    
    <content type="html"><![CDATA[<p>灶台上<br>塑胶篮 —   碗碟常用餐具<br>伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子<br>毛巾架 —锅盖 防烫手套</p><p>灶台下<br>文件盒 — 平底锅<br>死角<br>伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 </p><p>水槽下<br>滤筛 清洁剂<br>伸缩棒 滤网 架子</p><p>毛巾架</p><p>水槽上边<br>旅馆 凹字形  做成抽屉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;灶台上&lt;br&gt;塑胶篮 —   碗碟常用餐具&lt;br&gt;伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子&lt;br&gt;毛巾架 —锅盖 防烫手套&lt;/p&gt;
&lt;p&gt;灶台下&lt;br&gt;文件盒 — 平底锅&lt;br&gt;死角&lt;br&gt;伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 &lt;/p&gt;
&lt;p&gt;水槽下&lt;
      
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>厨房收纳</title>
    <link href="http://lsy563193.github.io/homework-KitchenStorage/"/>
    <id>http://lsy563193.github.io/homework-KitchenStorage/</id>
    <published>2018-11-19T00:55:31.000Z</published>
    <updated>2018-11-19T05:28:00.174Z</updated>
    
    <content type="html"><![CDATA[<p>灶台上<br>塑胶篮 —   碗碟常用餐具<br>伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子<br>毛巾架 —锅盖 防烫手套</p><p>灶台下<br>文件盒 — 平底锅<br>死角<br>伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 </p><p>水槽下<br>滤筛 清洁剂<br>伸缩棒 滤网 架子</p><p>毛巾架</p><p>水槽上边<br>旅馆 凹字形  做成抽屉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;灶台上&lt;br&gt;塑胶篮 —   碗碟常用餐具&lt;br&gt;伸缩棒 — 挂网 固定绑绳 挂钩 百元商店  勺子&lt;br&gt;毛巾架 —锅盖 防烫手套&lt;/p&gt;
&lt;p&gt;灶台下&lt;br&gt;文件盒 — 平底锅&lt;br&gt;死角&lt;br&gt;伸缩棒 挂网: 固定绑绳 挂钩 百元商店  勺子 &lt;/p&gt;
&lt;p&gt;水槽下&lt;
      
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>健身笔记</title>
    <link href="http://lsy563193.github.io/health-Fitness/"/>
    <id>http://lsy563193.github.io/health-Fitness/</id>
    <published>2018-11-07T01:23:23.000Z</published>
    <updated>2018-11-19T05:31:53.436Z</updated>
    
    <content type="html"><![CDATA[<p>本文是硬派健身笔记汇总<br><a id="more"></a></p><p>训练计划</p><p>1 臀腿 大<br>3 肩 小<br>4 背 中<br>6 胸 大</p><p>1 臀腿 小<br>3 肩 中<br>5 背 大<br>6 胸 小</p><p>小 %85<br>中 %90<br>大 %100</p><p>（大训练量=100%max重量、中训练量=90%max、小训练量=85%max）</p><p>肩<br>男性肩部重点：前束&amp;中束<br>整体：推举&amp;整体训练要点（中等重量、多次数、多组数、力竭）</p><p>后束：俯身侧平举&amp;练肩不粗脖小技巧（内旋）</p><p>中束：侧平举&amp;侧平举训练要点（小重量、手臂微屈）</p><p>前束：前平举&amp;前平举训练要点（多次数、多组数、力竭训练）</p><p>肩部训练计划<br>哑铃平举</p><p>站姿<br>俯身侧<br>站姿侧<br>前<br>L侧</p><p>屈膝卷腹<br>反向卷腹<br>空中单车<br>开合跳<br>自重侧弓步<br>原地高抬腿<br>靠墙静坐<br>平板支撑</p><p>最佳<br>上腹肌 悬腿卷腹<br>下腹肌 垂悬举腿<br>整体 空中单车</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是硬派健身笔记汇总&lt;br&gt;
    
    </summary>
    
      <category term="运动康复" scheme="http://lsy563193.github.io/categories/%E8%BF%90%E5%8A%A8%E5%BA%B7%E5%A4%8D/"/>
    
    
      <category term="硬派健身" scheme="http://lsy563193.github.io/tags/%E7%A1%AC%E6%B4%BE%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>向量分析</title>
    <link href="http://lsy563193.github.io/%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>http://lsy563193.github.io/向量分析/</id>
    <published>2018-11-06T07:47:33.000Z</published>
    <updated>2018-11-06T09:39:46.337Z</updated>
    
    <content type="html"><![CDATA[<p>向量分析是数学的分支，关心拥有两个维度或以上的向量的多元实分析。它有一套方程式及难题处理技巧对物理学及工程学特别有帮助。在微分几何与偏微分方程的研究中起着重要作用。它被广泛应用于物理和工程中，特别是在描述电磁场、引力场和流体流动的时候。<br><a id="more"></a></p><p>ab<ad:ac:db></ad:ac:db></p><c></c>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;向量分析是数学的分支，关心拥有两个维度或以上的向量的多元实分析。它有一套方程式及难题处理技巧对物理学及工程学特别有帮助。在微分几何与偏微分方程的研究中起着重要作用。它被广泛应用于物理和工程中，特别是在描述电磁场、引力场和流体流动的时候。&lt;br&gt;
    
    </summary>
    
    
      <category term="数学分支" scheme="http://lsy563193.github.io/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ceres-solver examples之pose_graph_2d学习笔记</title>
    <link href="http://lsy563193.github.io/slam-ceres-cartographer-pose-graph/"/>
    <id>http://lsy563193.github.io/slam-ceres-cartographer-pose-graph/</id>
    <published>2018-11-06T07:25:06.000Z</published>
    <updated>2018-11-06T07:33:15.225Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs the nonlinear least squares optimization problem from the pose</span></span><br><span class="line"><span class="comment">// graph constraints.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildOptimizationProblem</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Constraint2d&gt;&amp; constraints,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;* poses,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ceres::Problem* problem)</span> </span>&#123;</span><br><span class="line">  CHECK(poses != <span class="literal">NULL</span>);</span><br><span class="line">  CHECK(problem != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (constraints.empty()) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"No constraints, no problem to optimize."</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ceres::LossFunction* loss_function = <span class="literal">NULL</span>;</span><br><span class="line">  ceres::LocalParameterization* angle_local_parameterization =</span><br><span class="line">      AngleLocalParameterization::Create();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Constraint2d&gt;::const_iterator constraints_iter =</span><br><span class="line">           constraints.begin();</span><br><span class="line">       constraints_iter != constraints.end(); ++constraints_iter) &#123;</span><br><span class="line">    <span class="keyword">const</span> Constraint2d&amp; constraint = *constraints_iter;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_begin_iter =</span><br><span class="line">        poses-&gt;find(constraint.id_begin);</span><br><span class="line">    CHECK(pose_begin_iter != poses-&gt;end())</span><br><span class="line">        &lt;&lt; <span class="string">"Pose with ID: "</span> &lt;&lt; constraint.id_begin &lt;&lt; <span class="string">" not found."</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_end_iter =</span><br><span class="line">        poses-&gt;find(constraint.id_end);</span><br><span class="line">    CHECK(pose_end_iter != poses-&gt;end())</span><br><span class="line">        &lt;&lt; <span class="string">"Pose with ID: "</span> &lt;&lt; constraint.id_end &lt;&lt; <span class="string">" not found."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix3d sqrt_information =</span><br><span class="line">        constraint.information.llt().matrixL();</span><br><span class="line">    <span class="comment">// Ceres will take ownership of the pointer.</span></span><br><span class="line">    ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(</span><br><span class="line">        constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);</span><br><span class="line">    problem-&gt;AddResidualBlock(</span><br><span class="line">        cost_function, loss_function, &amp;pose_begin_iter-&gt;second.x,</span><br><span class="line">        &amp;pose_begin_iter-&gt;second.y, &amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">        &amp;pose_end_iter-&gt;second.x, &amp;pose_end_iter-&gt;second.y,</span><br><span class="line">        &amp;pose_end_iter-&gt;second.yaw_radians);</span><br><span class="line"></span><br><span class="line">    problem-&gt;SetParameterization(&amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">                                angle_local_parameterization);</span><br><span class="line">    problem-&gt;SetParameterization(&amp;pose_end_iter-&gt;second.yaw_radians,</span><br><span class="line">                                angle_local_parameterization);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The pose graph optimization problem has three DOFs that are not fully</span></span><br><span class="line">  <span class="comment">// constrained. This is typically referred to as gauge freedom. You can apply</span></span><br><span class="line">  <span class="comment">// a rigid body transformation to all the nodes and the optimization problem</span></span><br><span class="line">  <span class="comment">// will still have the exact same cost. The Levenberg-Marquardt algorithm has</span></span><br><span class="line">  <span class="comment">// internal damping which mitigate this issue, but it is better to properly</span></span><br><span class="line">  <span class="comment">// constrain the gauge freedom. This can be done by setting one of the poses</span></span><br><span class="line">  <span class="comment">// as constant so the optimizer cannot change it.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_start_iter =</span><br><span class="line">      poses-&gt;begin();</span><br><span class="line">  CHECK(pose_start_iter != poses-&gt;end()) &lt;&lt; <span class="string">"There are no poses."</span>;</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.x);</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.y);</span><br><span class="line">  problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.yaw_radians);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ceres-solver examples之pose_graph_2d学习笔记<br>ceres-solver库是google的非线性优化库，可以对slam问题，机器人位姿进行优化，使其建图的效果得到改善。pose_graph_2d是官方给出的二维平面上机器人位姿优化问题，需要读取一个g2o文件，运行程序后返回一个poses_original.txt和一个poses_optimized.txt，大家按字面意思理解，内部格式长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pose_id x y yaw_radians</span><br><span class="line">pose_id x y yaw_radians</span><br><span class="line">pose_id x y yaw_radians</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>得到这两个文件后，用官方提供的plot_results.py可以画出原始和优化后的位姿地图<br><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/ceres-pose-slam.png" alt="image"><br><a id="more"></a></p><h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><p>重要变量为以下几个：<br>constraints：vector，放入变量的类型为Constraint2d， 含义为机器人两个pose之间的限制，Constraint2d包括两个pose的id，相对坐标x，y，和协方差阵。这个变量描述的是观测量测量量measurement，即机器人认为自己感知到的正确的数据。</p><p>poses: map类指针，键值对为id和 Pose2d ，Pose2d是一个由id，世界坐标x，y，yaw角。这个变量描述的是实际机器人的世界坐标位置，是确确实实发生的事实。</p><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ceres will take ownership of the pointer.</span></span><br><span class="line"><span class="comment">//将需要的参数传入，设置残差，构造costfunction，使用自动求导方式</span></span><br><span class="line">ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(</span><br><span class="line">    constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);</span><br></pre></td></tr></table></figure><p>详情见下面的Costfunction的搭建。</p><h3 id="一、Costfunction的搭建"><a href="#一、Costfunction的搭建" class="headerlink" title="一、Costfunction的搭建"></a>一、Costfunction的搭建</h3><p>使用ceres库的关键是构造 costfunction ，ceres官方搭建的costfunction，同样有一个类表示，名为PoseGraph2dErrorTerm，具体如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoseGraph2dErrorTerm</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  PoseGraph2dErrorTerm(<span class="keyword">double</span> x_ab, <span class="keyword">double</span> y_ab, <span class="keyword">double</span> yaw_ab_radians,</span><br><span class="line">                       <span class="keyword">const</span> Eigen::Matrix3d&amp; sqrt_information)</span><br><span class="line">      : p_ab_(x_ab, y_ab),</span><br><span class="line">        yaw_ab_radians_(yaw_ab_radians),</span><br><span class="line">        sqrt_information_(sqrt_information) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="comment">//x_a,y_a(p_a)x_b,y_b(p_b)是世界下的ab坐标</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x_a, <span class="keyword">const</span> T* <span class="keyword">const</span> y_a, <span class="keyword">const</span> T* <span class="keyword">const</span> yaw_a,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> x_b, <span class="keyword">const</span> T* <span class="keyword">const</span> y_b, <span class="keyword">const</span> T* <span class="keyword">const</span> yaw_b,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals_ptr)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">1</span>&gt; p_a(*x_a, *y_a);</span><br><span class="line">    <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">1</span>&gt; p_b(*x_b, *y_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map映射类  将外部传进来的residuals_ptr映射到matrix&lt;3,1&gt;，取名为residuals_map</span></span><br><span class="line">    Eigen::Map&lt;Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; &gt; residuals_map(residuals_ptr);</span><br><span class="line"></span><br><span class="line">    residuals_map.<span class="keyword">template</span> head&lt;<span class="number">2</span>&gt;() =</span><br><span class="line">        RotationMatrix2D(*yaw_a).transpose() * (p_b - p_a) -</span><br><span class="line">        p_ab_.cast&lt;T&gt;();</span><br><span class="line">    residuals_map(<span class="number">2</span>) = ceres::examples::NormalizeAngle(</span><br><span class="line">        (*yaw_b - *yaw_a) - <span class="keyword">static_cast</span>&lt;T&gt;(yaw_ab_radians_));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scale the residuals by the square root information matrix to account for</span></span><br><span class="line">    <span class="comment">// the measurement uncertainty.</span></span><br><span class="line">    residuals_map = sqrt_information_.<span class="keyword">template</span> cast&lt;T&gt;() * residuals_map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态成员函数 构造costfunction   AutoDiffCostFunction 残差参数为3维  其他参数每个1维(参数是operator里的参数)</span></span><br><span class="line">  <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">double</span> x_ab, <span class="keyword">double</span> y_ab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">double</span> yaw_ab_radians,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Eigen::Matrix3d&amp; sqrt_information)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;PoseGraph2dErrorTerm, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                            <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> PoseGraph2dErrorTerm(</span><br><span class="line">        x_ab, y_ab, yaw_ab_radians, sqrt_information)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The position of B relative to A in the A frame.</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Vector2d p_ab_;</span><br><span class="line">  <span class="comment">// The orientation of frame B relative to frame A.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> yaw_ab_radians_;</span><br><span class="line">  <span class="comment">// The inverse square root of the measurement covariance matrix.</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Matrix3d sqrt_information_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中包括：<br>一个构造函数PoseGraph2dErrorTerm(x_ab, y_ab, yaw_ab_radians, sqrt_information)；<br>一个运算符重载operator()(x_a, y_a, yaw_a, x_b, y_b, yaw_b, residuals_ptr)，其中residuals_ptr指向的东西是计算出的残差；<br>一个构造costfunction的函数Create(x_ab, y_ab, yaw_ab_radians,&amp; sqrt_information)。</p><p>operator()的作用<br>传入参数计算残差，残差有三维，如下所示：<br>residual = information1/2 <em> [ raT </em> (pb - pa) - hat( pab ) ] （2维）<br>[ Normalize(yawb - yawa - hat( yawab ) ) ] （1维）</p><p>其中ra  是 timestep a 时从当前坐标系转向世界坐标系的旋转矩阵， pb  和 pa 是世界坐标系下timestep a 和 b 时的机器人位置，带hat的是测量值，是在时刻a时机器人坐标系下观察的测量值。</p><p>Create函数的作用<br>用来构造一个costfunction类，与一般不同的是，main函数里调用Create函数来构造costfunction.<br>定义求导方式，官方例程里定义的是自动求导方式，即ceres::AutoDiffCostFunction，&lt;&gt;里的参数是我们的PoseGraph2dErrorTerm类，和优化变量的维数，详情见代码注释。</p><h3 id="二、构造Problem"><a href="#二、构造Problem" class="headerlink" title="二、构造Problem"></a>二、构造Problem</h3><p>当costfunction搭建好后，给每个constraint都加入残差快AddResidualBlock, 官方例程没有用核函数，传入costfunction，传入待优化参数即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加problem 待优化的参数和PoseGraph2dErrorTerm里的operator保持一致</span></span><br><span class="line">problem-&gt;AddResidualBlock(</span><br><span class="line">    cost_function, loss_function, &amp;pose_begin_iter-&gt;second.x,</span><br><span class="line">    &amp;pose_begin_iter-&gt;second.y, &amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">    &amp;pose_end_iter-&gt;second.x, &amp;pose_end_iter-&gt;second.y,</span><br><span class="line">    &amp;pose_end_iter-&gt;second.yaw_radians);</span><br></pre></td></tr></table></figure></p><h3 id="三、LocalParameterization搭建"><a href="#三、LocalParameterization搭建" class="headerlink" title="三、LocalParameterization搭建"></a>三、LocalParameterization搭建</h3><p>理论详情见( <a href="https://blog.csdn.net/HUAJUN998/article/details/76222745" target="_blank" rel="noopener">https://blog.csdn.net/HUAJUN998/article/details/76222745</a> ），目的是利用一个增量构造Jacobian矩阵更新变量，具体不是很懂。官方例程只用它优化了yaw角，官方例程按照ceres库内的autodiff_local_parameterization.h定义方法定义了一个AngleLocalParameterization类，写在了例程中的angle_local_parameterization.h中，如下所示：<br>// Defines a local parameterization for updating the angle to be constrained in<br>// [-pi to pi).<br>class AngleLocalParameterization {<br> public:</p><p>  template <typename t=""><br>  bool operator()(const T<em> theta_radians, const T</em> delta_theta_radians,<br>                  T<em> theta_radians_plus_delta) const {    </em>theta_radians_plus_delta =<br>        NormalizeAngle(<em>theta_radians + </em>delta_theta_radians);</typename></p><pre><code>return true;</code></pre><p>  }</p><p>  //构造LocalParameterization函数，使用自动求导<br>  //参数目前不懂什么意思，应该是operator中输入输出参数的维数，Global Size和Local size<br>  static ceres::LocalParameterization* Create() {<br>    return (new ceres::AutoDiffLocalParameterization<anglelocalparameterization, 1="" 1,="">);<br>  }<br>};</anglelocalparameterization,></p><p>然后在主程序制造优化问题时，在迭代constraints之前就create了角度的localparameterization：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造yaw角度的localparameterization，更新角度 yaw_new = yaw + △yaw</span></span><br><span class="line">ceres::LocalParameterization* angle_local_parameterization =</span><br><span class="line">    AngleLocalParameterization::Create();</span><br></pre></td></tr></table></figure></p><p>等到迭代遍历时，就加入了每一个constraint内两个pose的yaw角，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为yaw角设置localparameterization</span></span><br><span class="line">problem-&gt;SetParameterization(&amp;pose_begin_iter-&gt;second.yaw_radians,</span><br><span class="line">                            angle_local_parameterization);</span><br><span class="line">problem-&gt;SetParameterization(&amp;pose_end_iter-&gt;second.yaw_radians,</span><br><span class="line">                            angle_local_parameterization);</span><br></pre></td></tr></table></figure></p><h3 id="四、固定初始位姿"><a href="#四、固定初始位姿" class="headerlink" title="四、固定初始位姿"></a>四、固定初始位姿</h3><p>官方例程上讲，优化问题是三个自由度的，没有造成互相之间完全的限制，这个问题叫做规范自由度（gauge freedom），详情见规范固定 ，具体不懂，反正按官方例程的意思是要固定第一个pose，不让它进行优化。<br>  // The pose graph optimization problem has three DOFs that are not fully<br>  // constrained. This is typically referred to as gauge freedom. You can apply<br>  // a rigid body transformation to all the nodes and the optimization problem<br>  // will still have the exact same cost. The Levenberg-Marquardt algorithm has<br>  // internal damping which mitigate this issue, but it is better to properly<br>  // constrain the gauge freedom. This can be done by setting one of the poses<br>  // as constant so the optimizer cannot change it.<br>  //规范固定，通过将一个pose设定成常量来限制规范自由度，具体含义不懂<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Pose2d&gt;::iterator pose_start_iter =</span><br><span class="line">    poses-&gt;begin();</span><br><span class="line">CHECK(pose_start_iter != poses-&gt;end()) &lt;&lt; <span class="string">"There are no poses."</span>;</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.x);</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.y);</span><br><span class="line">problem-&gt;SetParameterBlockConstant(&amp;pose_start_iter-&gt;second.yaw_radians);</span><br></pre></td></tr></table></figure></p><p>五、相关链接<br>以上是程序的主要问题，关于cpp的基础知识可参考下方链接：<br>ceres-solver官方教程</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Constructs the nonlinear least squares optimization problem from the pose&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// graph constraints.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BuildOptimizationProblem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;Constraint2d&amp;gt;&amp;amp; constraints,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                              &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;* poses,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                              ceres::Problem* problem)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(poses != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(problem != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (constraints.empty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOG(INFO) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;No constraints, no problem to optimize.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ceres::LossFunction* loss_function = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ceres::LocalParameterization* angle_local_parameterization =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      AngleLocalParameterization::Create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;Constraint2d&amp;gt;::const_iterator constraints_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           constraints.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       constraints_iter != constraints.end(); ++constraints_iter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Constraint2d&amp;amp; constraint = *constraints_iter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_begin_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        poses-&amp;gt;find(constraint.id_begin);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHECK(pose_begin_iter != poses-&amp;gt;end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Pose with ID: &quot;&lt;/span&gt; &amp;lt;&amp;lt; constraint.id_begin &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot; not found.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_end_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        poses-&amp;gt;find(constraint.id_end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHECK(pose_end_iter != poses-&amp;gt;end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Pose with ID: &quot;&lt;/span&gt; &amp;lt;&amp;lt; constraint.id_end &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot; not found.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Eigen::Matrix3d sqrt_information =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraint.information.llt().matrixL();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Ceres will take ownership of the pointer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ceres::CostFunction* cost_function = PoseGraph2dErrorTerm::Create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraint.x, constraint.y, constraint.yaw_radians, sqrt_information);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;AddResidualBlock(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cost_function, loss_function, &amp;amp;pose_begin_iter-&amp;gt;second.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_begin_iter-&amp;gt;second.y, &amp;amp;pose_begin_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_end_iter-&amp;gt;second.x, &amp;amp;pose_end_iter-&amp;gt;second.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;pose_end_iter-&amp;gt;second.yaw_radians);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;SetParameterization(&amp;amp;pose_begin_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                angle_local_parameterization);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    problem-&amp;gt;SetParameterization(&amp;amp;pose_end_iter-&amp;gt;second.yaw_radians,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                angle_local_parameterization);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// The pose graph optimization problem has three DOFs that are not fully&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// constrained. This is typically referred to as gauge freedom. You can apply&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// a rigid body transformation to all the nodes and the optimization problem&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// will still have the exact same cost. The Levenberg-Marquardt algorithm has&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// internal damping which mitigate this issue, but it is better to properly&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// constrain the gauge freedom. This can be done by setting one of the poses&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// as constant so the optimizer cannot change it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, Pose2d&amp;gt;::iterator pose_start_iter =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      poses-&amp;gt;begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CHECK(pose_start_iter != poses-&amp;gt;end()) &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;There are no poses.&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  problem-&amp;gt;SetParameterBlockConstant(&amp;amp;pose_start_iter-&amp;gt;second.yaw_radians);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Ceres-solver examples之pose_graph_2d学习笔记&lt;br&gt;ceres-solver库是google的非线性优化库，可以对slam问题，机器人位姿进行优化，使其建图的效果得到改善。pose_graph_2d是官方给出的二维平面上机器人位姿优化问题，需要读取一个g2o文件，运行程序后返回一个poses_original.txt和一个poses_optimized.txt，大家按字面意思理解，内部格式长这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pose_id x y yaw_radians&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到这两个文件后，用官方提供的plot_results.py可以画出原始和优化后的位姿地图&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/ceres-pose-slam.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>latex</title>
    <link href="http://lsy563193.github.io/tools-latex/"/>
    <id>http://lsy563193.github.io/tools-latex/</id>
    <published>2018-11-06T06:30:44.034Z</published>
    <updated>2018-11-06T06:30:44.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h2><p><a href="https://linux.cn/article-10172-1.html" target="_blank" rel="noopener">用这个漂亮的工具将方程式截图迅速转换为 LaTeX</a></p><p><a href="http://www.domuse.com/markdown-and-latex-equation-handbook.html" target="_blank" rel="noopener">Markdown语法和LaTeX数学记号速查手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;latex&quot;&gt;&lt;a href=&quot;#latex&quot; class=&quot;headerlink&quot; title=&quot;latex&quot;&gt;&lt;/a&gt;latex&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://linux.cn/article-10172-1.html&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具教程" scheme="http://lsy563193.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="工具" scheme="http://lsy563193.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达《深度学习》系列课程个人笔记</title>
    <link href="http://lsy563193.github.io/deep-learning-AndrewNgDeepLearningNotes/"/>
    <id>http://lsy563193.github.io/deep-learning-AndrewNgDeepLearningNotes/</id>
    <published>2018-11-06T04:26:45.337Z</published>
    <updated>2018-11-06T04:26:45.337Z</updated>
    
    <content type="html"><![CDATA[<p>吴恩达《深度学习》系列课程个人笔记<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吴恩达《深度学习》系列课程个人笔记&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://lsy563193.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Testing" scheme="http://lsy563193.github.io/tags/Testing/"/>
    
      <category term="Another Tag" scheme="http://lsy563193.github.io/tags/Another-Tag/"/>
    
  </entry>
  
  <entry>
    <title>Scan Matching in 2D SLAM by 张明明</title>
    <link href="http://lsy563193.github.io/slam-lidar-scan-matching-in-2d-slam/"/>
    <id>http://lsy563193.github.io/slam-lidar-scan-matching-in-2d-slam/</id>
    <published>2018-11-06T02:03:04.000Z</published>
    <updated>2018-11-06T04:24:14.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明"><a href="#【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明" class="headerlink" title="【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明"></a>【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明</h2><a id="more"></a><h2 id="概述-Scan-Matching"><a href="#概述-Scan-Matching" class="headerlink" title="概述 Scan Matching"></a>概述 Scan Matching</h2><p>两类<br>Real-Time Loop Cloare in 2D LIDAR SLAM.ICRA2016,提到scan matching的两种方法</p><h3 id="scan-to-ccan-—ICP-etc"><a href="#scan-to-ccan-—ICP-etc" class="headerlink" title="scan-to-ccan —ICP,etc"></a>scan-to-ccan —ICP,etc</h3><ul><li>计算成本大</li><li>累积误差,需进行闭环</li><li>容易进行闭环检测<h3 id="scan-to-map-matching-—Hector-SLAM-etc"><a href="#scan-to-map-matching-—Hector-SLAM-etc" class="headerlink" title="scan-to-map matching —Hector SLAM,etc"></a>scan-to-map matching —Hector SLAM,etc</h3></li><li>误差累积小计算成本小</li><li>难以闭环<br>更进一步的算法</li></ul><h2 id="2-ICP"><a href="#2-ICP" class="headerlink" title="2.ICP"></a>2.ICP</h2><h3 id="PL-ICP-开源-ros"><a href="#PL-ICP-开源-ros" class="headerlink" title="PL-ICP(开源,ros)"></a>PL-ICP(开源,ros)</h3><p>典型的是PL-ICP,一般icp是点到点的二阶最小均平和(ICP variant using a point to linear metric ICRA2009),速度快,大的旋转不够鲁棒<br>公式:<br>论文:</p><h3 id="PL-ICP加闭环（g2o）"><a href="#PL-ICP加闭环（g2o）" class="headerlink" title="PL-ICP加闭环（g2o）"></a>PL-ICP加闭环（g2o）</h3><ul><li>关键帧的选择策略</li><li><p>如何闭环<br>对之前的关键帧进行搜索</p></li><li><ol><li>有一个大的旋转就选择一个关键帧<br>缺点：没有submap(基于视觉的闭环),</li></ol></li><li><ol><li>有个局部小闭环，</li></ol></li><li><ol><li>google 也是一个小闭环(不开源)<h3 id="Hector-Slam"><a href="#Hector-Slam" class="headerlink" title="　Hector Slam"></a>　Hector Slam</h3></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明&quot;&gt;&lt;a href=&quot;#【泡泡机器人公开课】第二十三课：Scan-Matching-in-2D-SLAM-by-张明明&quot; class=&quot;headerlink&quot; title=&quot;【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明&quot;&gt;&lt;/a&gt;【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明&lt;/h2&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>graph slam ceres 实现</title>
    <link href="http://lsy563193.github.io/slam-GraphSLAM-ceres/"/>
    <id>http://lsy563193.github.io/slam-GraphSLAM-ceres/</id>
    <published>2018-11-06T02:03:04.000Z</published>
    <updated>2018-11-06T04:18:56.198Z</updated>
    
    <content type="html"><![CDATA[<p>本文是graph-slam 理论部分: ceres的实现部分<br><a id="more"></a></p><script type="math/tex; mode=display">e = (x_0)^2 + (x_1 - x_0 - 1)^2 + (l_0 - x_0 - 2)^2 + (l_0 - x_1 - 0.8)^2</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gflags/gflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"glog/logging.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F1</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f1 = x0;</span></span><br><span class="line">    residual[<span class="number">0</span>] = x1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F2</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f2 = (x1 - x0 -1.0)</span></span><br><span class="line">    residual[<span class="number">0</span>] = x1[<span class="number">0</span>] - x0[<span class="number">0</span>] - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F3</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> l0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f3 = l0 - x0 - 2.0</span></span><br><span class="line">    residual[<span class="number">0</span>] = l0[<span class="number">0</span>] - x0[<span class="number">0</span>] - <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F4</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> l0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> T* <span class="keyword">const</span> x1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        T* residual)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f4 = lo - x1 - 0.8</span></span><br><span class="line">    residual[<span class="number">0</span>] = l0[<span class="number">0</span>] - x1[<span class="number">0</span>] - <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DEFINE_string(minimizer, <span class="string">"trust_region"</span>,</span><br><span class="line">              <span class="string">"Minimizer type to use, choices are: line_search &amp; trust_region"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  CERES_GFLAGS_NAMESPACE::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> x0 =  <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">double</span> x1 = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">double</span> l0 =  <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//  double x4 =  1.0;</span></span><br><span class="line"></span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="comment">// Add residual terms to the problem using the using the autodiff</span></span><br><span class="line">  <span class="comment">// wrapper to get the derivatives automatically. The parameters, x0 through</span></span><br><span class="line">  <span class="comment">// x4, are modified in place.</span></span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F1),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x0, &amp;x1);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F2, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F2),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;x1, &amp;x0);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F3, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F3),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;l0, &amp;x0);</span><br><span class="line">  problem.AddResidualBlock(<span class="keyword">new</span> AutoDiffCostFunction&lt;F4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;(<span class="keyword">new</span> F4),</span><br><span class="line">                           <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;l0, &amp;x1);</span><br><span class="line"></span><br><span class="line">  Solver::Options options;</span><br><span class="line">  LOG_IF(FATAL, !ceres::StringToMinimizerType(FLAGS_minimizer,</span><br><span class="line">                                              &amp;options.minimizer_type))</span><br><span class="line">      &lt;&lt; <span class="string">"Invalid minimizer: "</span> &lt;&lt; FLAGS_minimizer</span><br><span class="line">      &lt;&lt; <span class="string">", valid options are: trust_region and line_search."</span>;</span><br><span class="line"></span><br><span class="line">  options.max_num_iterations = <span class="number">100</span>;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_QR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial x0 = "</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">4</span>)&lt;&lt; x0</span><br><span class="line">            &lt;&lt; <span class="string">", x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", l0 = "</span> &lt;&lt; l0</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the solver!</span></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  Solve(options, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final x0 = "</span> &lt;&lt; x0</span><br><span class="line">            &lt;&lt; <span class="string">", x1 = "</span> &lt;&lt; x1</span><br><span class="line">            &lt;&lt; <span class="string">", l0 = "</span> &lt;&lt; l0</span><br><span class="line">            &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://ceres-solver.org/nnls_tutorial.html#powell-s-function" target="_blank" rel="noopener">ceres-solver官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是graph-slam 理论部分: ceres的实现部分&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>graph slam 理论</title>
    <link href="http://lsy563193.github.io/slam-GraphSLAM-theory/"/>
    <id>http://lsy563193.github.io/slam-GraphSLAM-theory/</id>
    <published>2018-11-05T03:03:04.000Z</published>
    <updated>2018-11-06T06:58:44.867Z</updated>
    
    <content type="html"><![CDATA[<p>graph slam 理论<br><a id="more"></a></p><h2 id="什么是graph-slam"><a href="#什么是graph-slam" class="headerlink" title="什么是graph slam"></a>什么是graph slam</h2><p>图优化是比较常用的后端优化，cartographer也用到了这个方法。<br>假设有个一机器人，在初始位置$x_0$为0，先前移动1，看到了路标$l_0$为2，到达$x_2$的位置之后看到路标$l_0$的距离时0.8, 如图所示:</p><p><img src="https://raw.githubusercontent.com/lsy563193/image/master/cartographer_notes/grapher_slam.png" alt="graph_slam"></p><p>从$x_0$到$x_1$的距离其实是不确定的，不能够以1来表示，因为会有误差，学过卡尔曼就知道他的概率分布其实是</p><script type="math/tex; mode=display">\frac{1}{\sqrt{2\pi\delta}}\exp^{1/2}\frac{(x_1 - x_0 - 1)^2}{\delta^2}</script><p>是一个距离x0为1的正态分布。</p><p>上图中同样其他的边也是展示了这种节点与节点的约束.我们要做的就是通过建立这中约束然后通过这种约束求得最优解。<br>上图中有三种约束：</p><script type="math/tex; mode=display">x_0 : 0 \\x_0 -> x_1: 1 \\x_0 -> l_0: 2 \\x_1 -> l_0: 0.8</script><p>其中$x_0=0$被称为”初始位姿约束”</p><p>$x_0 -&gt; x_1: 1$被称为”初始位姿约束”</p><p>$x_0 -&gt; l_0: 2 x_1 -&gt; l_0: 0.8$ 为 “相对测量约束”</p><p>这些约束只有初始位姿约束时绝对的，所以在后面优化之后初始位姿不会变，这也要求初始位精度一定要高，不然后面的推断都会出错</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>我们现在讲解一下求解最优值的过程，根据上面的约束，我们可以得到四个方程</p><script type="math/tex; mode=display">\left \lbrace\begin{aligned}    x_0 = 0 \\    x_1 - x_0 -1 = 0 \\    l_0 - x_0 - 2 = 0 \\    l_0 - x_1 - 0.8 = 0\end{aligned}\right .</script><p>使用最小二乘法</p><!-- $$ --><!-- \underset{x}{min} \frac{1}{2}(||f_{i_1}(x_{i_1, ... , x_{i_k}})||^2) --><!-- $$ --><script type="math/tex; mode=display">\underset{x}{min}\sum_i^4e() =  = (x_0)^2 + (x_1 - x_0 - 1)^2 + (l_0 - x_0 - 2)^2 + (l_0 - x_1 - 0.8)^2</script><p>分别对$x_0$, $x_1$, $l_0$求偏导数</p><script type="math/tex; mode=display">\begin{array} { l } { \frac { \partial c } { \partial x _ { 0 } } = 2 x _ { 0 } - 2 \left( x _ { 1 } - x _ { 0 } - 1 \right) - 2 \left( l _ { 0 } - x _ { 0 } - 2 \right) } = 0\\ { \frac { \partial c } { \partial x _ { 1 } } = 2 \left( x _ { 1 } - x _ { 0 } - 1 \right) - 2 \left( l _ { 0 } - x _ { 1 } - 0.8 \right) } = 0\\  { \frac { \partial c } { \partial l _ { 0 } } = 2 \left( l _ { 0 } - x _ { 0 } - 2 \right) + 2 \left( l _ { 0 } - x _ { 1 } - 0.8 \right) }  =0\end{array}</script><p>最终得到</p><script type="math/tex; mode=display">\left[ \begin{array} { c c c } { 3 } & { - 1 } & { - 1 } \\ { - 1 } & { 2 } & { - 1 } \\ { - 1 } & { - 1 } & { 2 } \end{array} \right] \left[ \begin{array} { c } { x _ { 0 } } \\ { x _ { 1 } } \\ { l _ { 0 } } \end{array} \right] = \left[ \begin{array} { r } { - 3.0 } \\ { 0.2 } \\ { 2.8 } \end{array} \right] \quad \text { or } \quad \Omega \mu = \xi</script><p>接着矩阵求解线性方程组：</p><script type="math/tex; mode=display">\mu = \Omega ^ { - 1 } \xi = \left[ \begin{array} { c c c } { 3 } & { - 1 } & { - 1 } \\ { - 1 } & { 2 } & { - 1 } \\ { - 1 } & { - 1 } & { 2 } \end{array} \right] ^ { - 1 } \left[ \begin{array} { r } { - 3.0 } \\ { 0.2 } \\ { 2.8 } \end{array} \right] = \left[ \begin{array} { r } { 0 } \\ { 1.07 } \\ { 1.93 } \end{array} \right]</script><p>得到路标和机器人位姿：</p><script type="math/tex; mode=display">x _ { 0 } = 0 , x _ { 1 } = 1.07 , \text { and } l _ { 0 } = 1.93</script><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>// todo</p><h2 id="裁简"><a href="#裁简" class="headerlink" title="裁简"></a>裁简</h2><p>// todo</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/playlist?list=PLAwxTw4SYaPkCSYXw6-a_aAoXVKLDwnHK" target="_blank" rel="noopener">udacity ai-for robots 系列视频306到332</a></p><p><a href="https://blog.csdn.net/heyijia0327/article/details/47686523" target="_blank" rel="noopener">graph slam tutorial : 从推导到应用1</a></p><p><a href="https://www.cnblogs.com/gaoxiang12/p/5244828.html" target="_blank" rel="noopener">深入理解图优化与g2o：图优化篇</a></p><p><a href="https://blog.csdn.net/jsgaobiao/article/details/65628918" target="_blank" rel="noopener">Cartographer的原理探究——GraphSLAM理论基础</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;graph slam 理论&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer 调参日记</title>
    <link href="http://lsy563193.github.io/slam-cartographer-turn/"/>
    <id>http://lsy563193.github.io/slam-cartographer-turn/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:18:48.254Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer 2d 调参</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>使用1.0.0版本,因为公司扫地机用的是indigo版本,而我本机是用kinect版,所以我使用了docker来查看和调用rviz<br>Docker.indigo需要做些更改</p><ul><li>ARG CARTOGRAPHER_VERSION=release-1.0</li><li>cmake 升级到3.2版以上</li><li></li></ul><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>第一天<br>先从’/opt/ros/indigo/share/cartographer_ros/configuration’,如果找不到再到’/usr/share/cartographer-ros’找</p><ul><li>map 通常是map</li><li><strong>tracking_frame</strong>: 由SLAM算法跟踪的帧的ROS帧ID。如果使用IMU，它应该在其位置，尽管它可能是旋转的。一个常见的选择是“imu_link”。 不明,不用imu,写了odom,</li><li><strong>published_frame</strong>: ROS帧ID用作发布姿势的子帧。例如，如果“odom”帧由系统的不同部分提供，则为“odom”。在这种情况下，map_frame中的“ odom ” 姿势将被发布。否则，将其设置为“base_link”可能是合适的。 不明,写了odom</li><li><strong>odom_frame</strong>: 仅在provide_odom_frame为true时使用。published_frame 和map_frame之间的框架，用于发布（非循环关闭）本地SLAM结果。通常是“odom”。</li><li><strong>provide_odom_frame</strong>: 如果启用，则本地非闭环连续姿势将作为map_frame中的odom_frame发布。</li><li><strong>use_odometry</strong>: 如果启用，请在主题“ odom ”上订阅nav_msgs / Odometry。在这种情况下必须提供测距，并且信息将包含在SLAM中</li></ul><p>2d</p><ul><li>use_imu_data  如果不用false<br>先关闭全局slam</li><li>hit_probability 激光击中黑的程度</li><li>miss_probability 激光击不中白的程度</li></ul><p>online_correlative_scan_matching 更新initial_ceres_pose位置<br>ceres_scan_matcher_ pose_observation ,summary</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer 2d 调参&lt;/p&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析之local_slam</title>
    <link href="http://lsy563193.github.io/slam-cartographer-local_slam/"/>
    <id>http://lsy563193.github.io/slam-cartographer-local_slam/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:20:07.729Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析之local_slam<br><a id="more"></a></p><h2 id="LocalTrajectoryBuilder"><a href="#LocalTrajectoryBuilder" class="headerlink" title="LocalTrajectoryBuilder"></a>LocalTrajectoryBuilder</h2><p>Returns ‘MatchingResult’ when range data accumulation completed,<br>otherwise ‘nullptr’. Range data must be approximately horizontal<br>for 2D SLAM. <code>TimedPointCloudData::time</code> is when the last point in<br><code>range_data</code> was acquired, <code>TimedPointCloudData::ranges</code> contains the<br>relative time of point with respect to <code>TimedPointCloudData::time</code>.</p><h3 id="LocalTrajectoryBuilder-1"><a href="#LocalTrajectoryBuilder-1" class="headerlink" title="LocalTrajectoryBuilder"></a>LocalTrajectoryBuilder</h3><p>AddImuData添加imuData</p><h3 id="extrapolator"><a href="#extrapolator" class="headerlink" title="extrapolator_"></a>extrapolator_</h3><p>局部地图的位姿推断器。cartographer_ros不一样,addImuData时添加</p><h3 id="雷达数据的处理过程"><a href="#雷达数据的处理过程" class="headerlink" title="雷达数据的处理过程"></a>雷达数据的处理过程</h3><p>Node::HandleLaserScanMessage<br>SensorBridge::HandleLaserScanMessage<br>    ToPointCloudWithIntensities<br>    HandleLaserScan<br>    HandleRangefinder<br>CollatedTrajectoryBuilder  AddSensorData<br>    AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>    Dispatch<br>    callback</p><p>global_trajectory_builder::AddSensorData<br>LocalTrajectoryBuilder2D::AddRangeData<br>RangeDataCollator::AddRangeData<br>    extrapolator_-&gt;ExtrapolatePose<br>    accumulated_range_data_<br>    TransformToGravityAlignedFrameAndFilter<br>AddAccumulatedRangeData<br>TransformRangeData<br><!-- ScanMatch --><br><!-- InsertIntoSubmap --><br>local_slam_result_callback_<br>OnLocalSlamResult<br>GetTrajectoryStates<br>scan_matched_point_cloud_publisher_</p><h3 id="Imu的处理过程"><a href="#Imu的处理过程" class="headerlink" title="Imu的处理过程"></a>Imu的处理过程</h3><p>Node::HandleImuMessage<br>    sensor_samplers_ 分频，脉冲未到不处理<br>    extrapolators_.at(trajectory_id).AddImuData<br>SensorBridge::HandleImuMessage<br>CollatedTrajectoryBuilder::AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>BlockingQueue::Push, Dispatch callback<br>LocalTrajectoryBuilder2D::AddImuData<br>PoseExtrapolator::AddImuData<br>PoseGraph2D::AddImuData<br>OptimizationProblem2D::AddImuData</p><h3 id="Odometry的处理过程"><a href="#Odometry的处理过程" class="headerlink" title="Odometry的处理过程"></a>Odometry的处理过程</h3><p>Node::HandleOdometryMessage<br>    sensor_samplers_ 分频，脉冲未到不处理<br>    extrapolators_.at(trajectory_id).AddOdometryData  角速度和线速度<br>SensorBridge::HandleOdometryMessage<br>CollatedTrajectoryBuilder::AddData<br>Collator::AddSensorData<br>OrderedMultiQueue::Add<br>BlockingQueue::Push, Dispatch callback<br>LocalTrajectoryBuilder2D::AddOdometryData<br>PoseExtrapolator::AddOdometryData<br>PoseGraph2D::AddOdometryData<br>OptimizationProblem2D::AddOdometryData</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析之local_slam&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析之sensor</title>
    <link href="http://lsy563193.github.io/slam-cartographer-sensor/"/>
    <id>http://lsy563193.github.io/slam-cartographer-sensor/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-06T04:28:01.928Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析之sensor<br><a id="more"></a></p><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><p>ImuTracker:  使用IMU的角速度和线性加速度跟踪方向。 因为平均线性加速度（假设慢速运动）是重力的直接测量，所以滚动/俯仰不会漂移，尽管是偏航。</p><p>Map_build: 使用用于局部子图TrajectoryBuilders和用于闭环的PoseGraph来连接整个SLAM堆栈。<br>成员只有五个  MapBuilderOptions; thread_pool_; pose_graph_; CollatorInterface sensor_collator_; trajectory_builders_ all_trajectory_builder_options_; ,其中pose_graph_用于全局优化，<br>  trajectory_builders_用于子地图构建. sensor_collator_ 用于数据收集<br>  我们先看sensor_collator_,<br>sensor_collator_ SensorInterface</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p>  图优化</p><p>  <a href="https://blog.csdn.net/u012209790/article/details/82629422" target="_blank" rel="noopener">Real-time correlative scan matching 论文算法分析</a><br>  <a href="https://blog.csdn.net/u012209790/article/details/82735923" target="_blank" rel="noopener">Cartographer 的前端算法思路</a></p><p>  <a href="https://docs.ros.org/api/cartographer/html/classcartographer_1_1mapping_1_1constraints_1_1ConstraintBuilder2D.html" target="_blank" rel="noopener">cartographer Documentation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析之sensor&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer源码解析</title>
    <link href="http://lsy563193.github.io/slam-cartographer-notes/"/>
    <id>http://lsy563193.github.io/slam-cartographer-notes/</id>
    <published>2018-08-08T11:43:14.000Z</published>
    <updated>2018-11-28T09:08:39.638Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer源码解析流程<br><a id="more"></a></p><p>AddNode</p><p>核心函数是ComputeConstraintsForNode,为节点添加约束，并且在后台开始扫描匹配.<br>node_id是分配的节点号，insertion_submap是允许插入的子地图，即最后两张，newly_finished_submap最后第二张子地图是否刚满（完成）<br>WorkItem::Result ComputeConstraintsForNode(node_id, insertion_submaps, newly_finished_submap);</p><p>ComputeConstraintsForNode</p><ol><li>把轨迹节点添加到optimization_problem_.<br>optimization_problem_-&gt;AddTrajectoryNode(<pre><code> matching_id.trajectory_id, optimization::NodeSpec2D{constant_data-&gt;time, local_pose_2d,                          global_pose_2d,                          constant_data-&gt;gravity_alignment})</code></pre>2.遍历正在插入子图，填充图优化数据中的子地图数据和内部约束。<br>data_.submap_data.at(submap_id).node_ids.emplace(node_id);<br>data_.constraints.push_back(<pre><code>   Constraint{submap_id,              node_id,              {transform::Embed3D(constraint_transform),               options_.matcher_translation_weight(),               options_.matcher_rotation_weight()},              Constraint::INTRA_SUBMAP});</code></pre></li></ol><p>trajectory_nodes_.at(node_id).constant_data<br>constant_data-&gt;local_pose()<br>submap.local_pose()</p><p>constraint_transform</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer源码解析流程&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>cartographer论文翻译:2d-lidar-slam的实时闭环</title>
    <link href="http://lsy563193.github.io/slam-real-time-loop-closure-in-2d-lidar-slam/"/>
    <id>http://lsy563193.github.io/slam-real-time-loop-closure-in-2d-lidar-slam/</id>
    <published>2018-08-07T03:03:04.000Z</published>
    <updated>2018-12-13T01:40:42.085Z</updated>
    
    <content type="html"><![CDATA[<p>cartographer 论文翻译<br><a id="more"></a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>LIDAR SLAM是获取平面地图的有效方法。  构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和<code>闭环</code>。 为了实现实时<code>闭环</code>，我们使用branch-and-bound将扫描到Submap匹配计算为约束。</p><h2 id="I-简介"><a href="#I-简介" class="headerlink" title="I. 简介"></a>I. 简介</h2><p>本文的贡献是一种新的方法，用于降低计算激光数据的闭环约束的需求量。</p><h2 id="II-相关工作"><a href="#II-相关工作" class="headerlink" title="II. 相关工作"></a>II. 相关工作</h2><p><code>Scan-to-scan matching</code>经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 它的缺点是很快就会累积误差。</p><p><code>Scan-to-map matching</code>有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。<br>在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的<code>Scan-to-map matching</code>是有效且稳健的。<br>在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。</p><p><code>pixel-accurate scan matching</code>方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于<code>闭环检测</code>很有用。</p><p>一些方法着重于通过匹配激光扫描的<code>提取特征</code>来改善计算成本[4]。其他用于<code>闭环检测</code>方法包括<code>基于直方图的匹配</code>[6]，扫描数据中的<code>特征检测</code>，以及使用<code>机器学习</code>[7]。</p><p><code>解决累积局部误差</code>的两种常用方法是<code>粒子滤波器</code>和<code>基于图形</code>的SLAM [2]，[8]。</p><p><code>基于图形</code>的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。<br>在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部<code>scan-to-scan</code>匹配，以及基于Submap特征的直方图的重叠局部图的匹配。</p><h2 id="III-系统概述"><a href="#III-系统概述" class="headerlink" title="III. 系统概述"></a>III. 系统概述</h2><p>Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 <code>Laser scans</code>被插入到最优估算位姿的Submap中，假定在短时间内足够准确。 而<code>Scan match</code>发生在最近的<code>Submap</code>上，因此它只取决于最近的扫描，全局误差会累积。</p><p>cartographer <code>定期</code>运行<code>位姿优化</code>来减少误差积累。<br>当一个Submap完成时，就不会再将新的扫描插入其中，它将参与<code>Scan match</code>以获得<code>闭环</code>。<br>所有已完成的Submap和扫描都会自动考虑进行<code>闭环</code>。<br>如果它们基于当前的<code>位姿估计</code>足够<code>接近</code>，则<code>Scan match器</code>试图在Submap中找到扫描。<br>如果在当前<code>估计位姿</code>的<code>搜索窗口</code>中找到足够好的匹配，则将其作为<code>闭环约束</code>添加到<code>优化问题</code>。</p><p>通过每隔几秒完成一次优化，我们的经验就是当<code>重新访问位置</code>时<code>立即闭环</code>。<br>这导致了<code>软实时约束</code>，即<code>闭环Scan match</code>必须比添加新扫描更快，否则它会明显落后,闭环失败。<br>我们通过对每个完成的Submap使用<code>branch-and-bound</code>和几个<code>预先计算的网格</code>来实现这一点。</p><h2 id="IV-局部2d-slam"><a href="#IV-局部2d-slam" class="headerlink" title="IV. 局部2d slam"></a>IV. 局部2d slam</h2><p>我们的系统将单独的局部和全局方法结合到2D SLAM中。<br>两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为<code>扫描</code>。<br>在不平的地面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。<br>在我们的局部方法中，每个连续扫描与<code>Submap</code>相匹配，使用<code>非线性优化</code>将扫描与Submap对齐; 该过程称为<code>real time Scan match</code>,其随着时间累积误差，我们的全局方法将其去除，如第五节所述。</p><h3 id="A-Scans"><a href="#A-Scans" class="headerlink" title="A. Scans"></a>A. Scans</h3><p>Submap构造是重复对齐scan和Submap坐标帧的迭代过程。<br>随着扫描的原点在$0 \in \Bbb R^2$，我们现在将关于扫描点的信息写为$H = \lbrace h_k\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$。<br>Submap帧中扫描帧的姿态$\xi$表示为变换$T_\xi$，它将扫描点从扫描帧严格转换为Submap帧，定义为</p><script type="math/tex; mode=display">T_\xi = \underbrace{\left(    \begin {matrix}        cos\xi_\delta & -sin\xi_\delta \\        sin\xi_\delta & sin\xi_\delta    \end{matrix} \right)}_{R_\xi}p +\underbrace{\left(\begin {matrix}     \xi_x \\    \xi_y\end{matrix} \right)}_{t_\xi}.\tag1</script><h3 id="B-Submaps"><a href="#B-Submaps" class="headerlink" title="B. Submaps"></a>B. Submaps</h3><p>一些连续扫描用于构建Submap。<br>这些Submap采用概率网格的形式$M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$，它以给定分辨率<code>r</code>的离散网格点进行映射，例如5厘米，到值。<br>这些值可以被认为是网格点被阻挡的概率。<br>对于每个网格点，我们将相应的<code>像素</code>定义为最接近该网格点的所有点。<br>每当要将扫描插入概率网格时，计算用于命中的一组网格点和用于未命中的不相交组。<br>对于每次击中，我们将最近的网格点插入到命中集中。<br>对于每个未命中，我们插入与每个像素相关联的网格点，该网格点与扫描原点和每个扫描点之间的一条光线相交，不包括已经在命中集中的网格点。<br>如果每个以前未观察到的网格点位于其中一个集合中，则会为其分配概率$p_{hit}$ 或 $p_{miss}$。<br>如果已经观察到网格点x，我们更新命中和未命中的几率</p><script type="math/tex; mode=display">odds(p) = \frac{p}{1-p}, \tag1</script><script type="math/tex; mode=display">M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1</script><p>and equivalently for misses</p><p>等同于未命中</p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/carto_submap.png?raw=true" alt="image"></p><h3 id="C-Ceres-scan-matching"><a href="#C-Ceres-scan-matching" class="headerlink" title="C. Ceres scan matching"></a>C. Ceres scan matching</h3><p>在将扫描插入Submap之前，扫描位姿<code>ξ</code>相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到<code>最大概率</code>的扫描位姿。 我们将其视为<code>非线性最小二乘问题</code></p><script type="math/tex; mode=display"> \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2</script><p>其中$T\xi$根据扫描位姿将$h_k$从scan帧变换到Submap帧。<br>函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。<br>我们使用双三次插值。<br>结果，可以发生区间$[0, 1]$之外的值，但是被认为是无关紧要的。<br>这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。<br>由于这是局部优化，因此需要良好的初始估计。<br>能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。<br>虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。</p><h2 id="V-闭环"><a href="#V-闭环" class="headerlink" title="V. 闭环"></a>V. 闭环</h2><p>由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。<br>对于仅几十次连续扫描，累积误差很小。<br>通过创建许多小Submap来处理更大的空间。<br>我们的方法，优化所有扫描和Submap的位姿，遵循<code>稀疏位姿调整</code>[2]。<br>插入扫描的相对位姿存储在内存中，以用于<code>闭环优化</code>。<br>除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由scan和Submap组成的对都被认为是<code>闭环</code>。<br>global scan matcher在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中</p><h3 id="A-优化问题"><a href="#A-优化问题" class="headerlink" title="A. 优化问题"></a>A. 优化问题</h3><p><code>闭环优化</code>，和<code>Scan match</code>一样，也被称为<code>非线性最小二乘问题</code>，它允许轻松添加残差以考虑其他数据。<br>每隔几秒钟，我们使用Ceres [14]来计算解决方案</p><script type="math/tex; mode=display">\underset{\Xi ^m,\Xi ^n}{argmin} \frac{1}{2}\sum _{ij}\rho (E^2(\xi _i^m,\xi _j^s;\sigma _{ij},\xi _{ij}))\tag{SPA}</script><p>在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。<br>这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。<br>对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。<br>协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。<br>这种约束的残差E由下式计算</p><script type="math/tex; mode=display">E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4</script><script type="math/tex; mode=display">e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - \left(     \begin{matrix}     R_{\xi_i^m}^{-1}(t_{\xi_i^m}-t_{\xi_j^s}) \\    \xi_{ij} - \xi_{j;\theta}^s    \end{matrix}\right).\tag5</script><p>损失函数$\rho$，例如<code>Huber loss</code>，用于减少当<code>Scan match</code>为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。<br>例如，这可能发生在局部对称环境中，例如办公室隔间。<br>异常值的替代方法包括[16]。</p><h3 id="B-Branch-and-bound-scan-match"><a href="#B-Branch-and-bound-scan-match" class="headerlink" title="B. Branch-and-bound scan match"></a>B. Branch-and-bound scan match</h3><p>我们对最佳的<code>像素精确匹配</code>感兴趣</p><script type="math/tex; mode=display">\xi^* = \underset{\xi\in\omega}{argmax}\sum_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}</script><p>其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。</p><p>通过仔细选择步长来提高效率。<br>我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。<br>我们推导出使用余弦定律</p><script type="math/tex; mode=display">d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\</script><script type="math/tex; mode=display">\xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7</script><p>我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30\degree$</p><script type="math/tex; mode=display">w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W_\theta}{\xi_\theta}\rceil.\tag8</script><p>这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口，</p><script type="math/tex; mode=display">\overline{W} = \{-w_x,...,w_x\} \times \{-w_y,...,w_y\} \times \{-w_\theta,...,w_\theta\}\tag9</script><script type="math/tex; mode=display">W = \{\xi_0 + (rj_x, rj_y, \xi_\theta j_\theta):(j_x,j_y,j_\theta) \in \overline{W}\}\tag{10}</script><p>找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。</p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo1.png?raw=true" alt="image"></p><p>相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。<br>有关通用方法，请参见算法2。<br>    这种方法最初是在混合整数线性程序的背景下提出的[17]。<br>关于这个主题的文献很广泛; 见[18]简短概述。<br>主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。<br>每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。<br>叶节点是单体; 每个代表一个可行的解决方案。<br>请注意，算法是准确的。<br>只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。<br>在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。</p><p>为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。</p><h4 id="1-节点选择"><a href="#1-节点选择" class="headerlink" title="1) 节点选择:"></a>1) 节点选择:</h4><p>在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。<br>这取决于两件事：良好的上限和良好的当前解决方案。<br>后一部分由DFS帮助，它可以快速评估许多叶节点。<br>由于我们不希望将不良匹配作为<code>闭环</code>约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。<br>由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。<br>关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。<br>算法3是这种方法。</p><h4 id="2-分支规则："><a href="#2-分支规则：" class="headerlink" title="2) 分支规则："></a>2) 分支规则：</h4><p>树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。<br>高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换：</p><script type="math/tex; mode=display">\overline {\overline{W}} = \Bigg(\{j_x,j_y\} \in \Bbb{Z}^2:  \\\Big\lbrace\begin{array}{l}        c_x \leq j_x < c_x + 2^{ch} \\        c_x \leq j_x < c_x + 2^{ch}        \end{array}\Big\rbrace        \times \lbrace c_\theta \rbrace \Bigg) ,\tag{11}</script><script type="math/tex; mode=display">\overline{W}_c = \overline{\overline{W}} \cap \overline{W}\tag{12}</script><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo2.png?raw=true" alt="image"></p><p><img src="https://github.com/lsy563193/image/blob/master/cartographer_notes/algo3.png?raw=true" alt="image"></p><p>叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。</p><p>在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口</p><script type="math/tex; mode=display">\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\\overline{W}_{0,x} =  \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\C_0 = \overline{W}_{0,x} \times \overline{W}_{0,y} \times \overline{W}_{0,\theta} \times \{h_0\}. \tag{13}</script><p>At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$<br>在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$</p><script type="math/tex; mode=display">C_c = ((\{c_x,c_x + 2^{c_h-1}\} \times {c_y, c_y + 2^{c_h-1} \times c_\theta}) \cap \overline{W}) \times \{c_h-1\}\tag{14}</script><h4 id="3-计算上界："><a href="#3-计算上界：" class="headerlink" title="3) 计算上界："></a>3) 计算上界：</h4><p>分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。<br>我们用</p><script type="math/tex; mode=display">score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\\geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M_{nearest}(T\xi_{j}h_{k})\\\underset{j\in \overline{W_c}}{max}\sum_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k})\tag{15}</script><p>为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。<br>每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。<br>请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。</p><script type="math/tex; mode=display">score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16}</script><script type="math/tex; mode=display">M_{precomp}^{ch}(x,y) =      \underset    {\begin{matrix}        x^, \in [x,x+r(2^h-1)] \\        y^, \in [y,y+r(2^h-1)]    \end{matrix}}    {max}M_{nearest}(x^, , y^,) \tag{17}</script><p>与叶节点一样使用$\xi_c$。<br>请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。<br>图3给出了这种预先计算的网格的一个例子。</p><p>为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。<br>然后我们计算一组预先计算的网格，并开始匹配它。</p><p>对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。<br>使用该中间结果，然后构造下一个预先计算的网格。</p><p>如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。<br>连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。<br>对于空的值集合，此列表为空。<br>使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。</p><p>计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。<br>由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] E. Olson，<code>M3RSM：多对多分辨率Scan match</code>，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。</p><p>[2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，<code>`稀疏位姿调整</code>2D绘图`，在IROS，台湾台北，2010年10月10日。</p><p>[3] F. Lu和E. Milios，<code>用于环境绘图的全局一致范围扫描对准</code>，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。</p><p>[4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，<code>两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测</code>，Robotica，vol。 32，不。 01，pp.19-41,2014。</p><p>[5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，<code>具有完整3D运动估计的灵活且可扩展的SLAM系统</code>，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。</p><p>[6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，<code>使用几何地标关系的2D LIDAR扫描中的大规模地点识别</code>，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。</p><p>[7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，<code>学习close闭合范围数据循环</code>，<code>国际机器人研究杂志</code>，第一卷。 30，不。 14，pp.1728-1754,2011。</p><p>[8] G. Grisetti，C。Stachniss和W. Burgard，<code>通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器</code>，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。</p><p>[9] G. D. Tipaldi，M。Braun和K. O. Arras，<code>FLIRT：2D范围数据的兴趣区域，应用于机器人导航</code>，在实验机器人中。 Springer，2014年，第695-710页。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cartographer 论文翻译&lt;br&gt;
    
    </summary>
    
      <category term="slam技术" scheme="http://lsy563193.github.io/categories/slam%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cartographer" scheme="http://lsy563193.github.io/tags/cartographer/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms-notes</title>
    <link href="http://lsy563193.github.io/algorithms-notes/"/>
    <id>http://lsy563193.github.io/algorithms-notes/</id>
    <published>2018-07-31T01:22:51.000Z</published>
    <updated>2018-11-06T04:29:06.044Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithms-notes</p><p>Algorithms-notes<br>Algorithms-notes<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithms-notes&lt;/p&gt;
&lt;p&gt;Algorithms-notes&lt;br&gt;Algorithms-notes&lt;br&gt;
    
    </summary>
    
      <category term="算法相关" scheme="http://lsy563193.github.io/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="algo" scheme="http://lsy563193.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>静脉曲张的原理和治疗方法</title>
    <link href="http://lsy563193.github.io/health-VaricoseVeins/"/>
    <id>http://lsy563193.github.io/health-VaricoseVeins/</id>
    <published>2018-07-30T03:25:06.000Z</published>
    <updated>2018-11-19T10:03:28.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>静脉曲张形成的主要原因是由于<strong>先天性血管壁膜</strong>比较薄弱或长时间维持相同姿势很少改变，<strong>血液蓄积下肢</strong>，在日积月累的情况下<strong>破坏静脉瓣膜</strong>而产生<strong>静脉压过高</strong>，使血管突出皮肤表面的症状。<br><a id="more"></a></p><h2 id="改善方法"><a href="#改善方法" class="headerlink" title="改善方法"></a>改善方法</h2><h3 id="物理治疗-弹力袜"><a href="#物理治疗-弹力袜" class="headerlink" title="物理治疗: 弹力袜"></a><strong>物理治疗: 弹力袜</strong></h3><p>1.1 <strong>弹力袜促进血液回流</strong>: 为什么有用?: 弹力袜在腿上的压力不一样，利用这种压力梯度可以促进血液回流。</p><blockquote><p><strong>注意</strong>：　但不是所有的人都适合穿弹力袜，静脉曲张较严重的患者穿弹力袜之前最好咨询医生。</p></blockquote><p>1.2 <strong>按摩加速血液循环</strong>:<br>在腿部感到疲劳时，或者平时方便的时候对腿部进行简单的揉捏，加速血液循环。</p><blockquote><p><strong>注意</strong>：坚持下来，静脉曲张就可以得到有效的改善.<br>至于按摩可以改善血液循环的原理其实并不是很有科学依据，知乎上还是能找到一些,<br>但是找不到靠谱的解释，本人实践过，确实是没有什么改善,不过也有可能是按摩手法的不对。<br>网上找了能够促进血液循环的按摩方法.<br><a href="https://www.youtube.com/watch?v=TcDrua76qDo" target="_blank" rel="noopener"><strong>静脉曲张按摩手法</strong></a></p></blockquote><h3 id="运动加强静脉管壁"><a href="#运动加强静脉管壁" class="headerlink" title="运动加强静脉管壁"></a><strong>运动加强静脉管壁</strong></h3><p>从血液动力学的角度进行观察，健康的人在运动时，由于瓣膜的功能正常，肌肉的规律性收缩使得深部静脉血液回流加速，皮下静脉的压力甚至可能比静止时还低。所以进行适当的跑步锻炼，不但不会引起下肢静脉曲张，恰恰相反，跑步可以使腿部肌肉活动增强，挤压静脉内的血液，使其流动更加顺畅，还有助于预防和改善下肢静脉曲张。对于静脉曲张的患者来说，当然也可以进行如<strong>慢跑、游泳、单车、跳绳</strong>等运动。但是因为静脉瓣膜功能受损，应当避免像举重、快速冲刺短跑、跳远、投掷等引起腹压增高的活动。</p><blockquote><p><strong>注意</strong>:但是严重的静脉曲张患者，不要一下子运动过量，否则容易对心血管造成伤害。</p></blockquote><h3 id="食疗"><a href="#食疗" class="headerlink" title="食疗"></a><strong>食疗</strong></h3><p>　　多食用蔬菜、水果、豆类等纤维素含量较高的食物，适量食用瘦牛肉、鸡肉等，多吃含维E的食物，如洋白菜、菠菜、橙子等可以<strong>疏通经络，改善血液循环</strong>，减轻腿部的沉重感。</p><blockquote><p>1、在静脉曲张的饮食中新鲜蔬菜和水果不能少：新鲜蔬菜和水果含有大量的维生素及矿物质，可以改善组织的氧化作用，增加血液循环，提高机体免疫力。如新鲜水果中含有大量维生素 C ，可以通过降低血凝倾向，改善血液循环，促进康复，预防淤伤。新鲜蔬菜含有丰富纤维素，能避免便秘，保持肠道清洁，改善肛周围的血液循环，预防末梢静脉曲张和痔疮的形成。</p><p>2、要有足够的蛋白质：静脉曲张的饮食中要多含蛋白质丰富的食物，如鱼、牛、羊肉等，大豆以及豆制品也含有丰富的植物蛋白，也应多吃。充足的蛋白质可以维持体内所有营养物质的平衡，增强免疫力，保护细胞，还可以乳化脂肪，促进血液循环。</p><p>3、含维生素 E 丰富的食物：静脉曲张的饮食要多含维生素E的食物，可以改善血液循环，减轻腿部的沉重感。含维生素 E 丰富的食物有：洋白菜、菠菜、甘蓝、麦芽、坚果类、大豆、全麦、粗粮、蛋等都是静脉曲张的饮食注意事项。</p></blockquote><h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>预防的扎6招防小腿静脉曲张 睡前抬腿久站抬脚尖</p><h3 id="1-睡前抬腿"><a href="#1-睡前抬腿" class="headerlink" title="1. 睡前抬腿"></a>1. 睡前抬腿</h3><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-taijiao.jpg" alt="静脉曲张抬脚"></p><h3 id="2-久站抬脚尖"><a href="#2-久站抬脚尖" class="headerlink" title="2. 久站抬脚尖"></a>2. 久站抬脚尖</h3><p>静脉曲张的成因是静脉瓣膜功能不良，静脉血液向下逆流而形成静脉曲张。因此，站立时，要每隔一段时间就抬脚尖，让肌肉收缩，给静脉血液加压，让血液往心脏方向流动，致使静脉瓣膜打开维持正常功能。一般来说，小腿感到酸麻时，就是在提醒你要抬脚尖了。</p><h3 id="3-穿平跟鞋"><a href="#3-穿平跟鞋" class="headerlink" title="3. 穿平跟鞋"></a>3. 穿平跟鞋</h3><p>平跟鞋有助于预防静脉曲张，在体育锻炼时一定要穿有海绵垫的运动鞋或旅游鞋，对缓解腿部压力，预防静脉曲张很有帮助。</p><h3 id="4-赤足"><a href="#4-赤足" class="headerlink" title="4. 赤足"></a>4. 赤足</h3><p>在条件允许的情况下，下班回家后，将鞋脱掉，赤足或穿拖鞋行走，可以改善足部血液循环，并使足部肌肉得到锻炼。</p><h3 id="5-抬高下肢"><a href="#5-抬高下肢" class="headerlink" title="5. 抬高下肢"></a>5. 抬高下肢</h3><p>站立工作者在工间休息时，宜将鞋脱掉，双脚抬高，足部要高于心脏30厘米以上，下班回到家中后也应将双脚抬高15分钟，缓解血液对下肢的压力。</p><h3 id="6-改掉不良如厕习惯"><a href="#6-改掉不良如厕习惯" class="headerlink" title="6. 改掉不良如厕习惯"></a>6. 改掉不良如厕习惯</h3><p>在上厕所时看书报，这是很不好的生活习惯。上厕所时看书报，蹲踞时间长会给下肢静脉增加过多的负担，造成血管内滞血，因此这种习惯一定要改掉。</p><h2 id="装备"><a href="#装备" class="headerlink" title="装备:"></a>装备:</h2><h3 id="1-弹力袜子"><a href="#1-弹力袜子" class="headerlink" title="1. 弹力袜子"></a>1. 弹力袜子</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>起床穿。 睡觉不穿。 半年换。最好三个月，看物料和生活习惯。因为弹性会不断下降，没弹性等于没压力，所以穿鬆了就要换。</li><li>手洗＋不晒太阳＋摊乾＋不用化学清洗剂(柔顺／漂白)可以让弹性保持久一点，这个就看自己勤不勤快了。</li><li>最重要的一点，运动。简单说就是让下肢肌肉更好的泵血，更好的把血从下肢输送回心脏，另外也可以避免和减少长期穿压力袜后依赖和股肉无力的情况。</li></ul><h4 id="选择型号"><a href="#选择型号" class="headerlink" title="选择型号"></a>选择型号</h4><ol><li>根据穿者的腿部症状选择合适的静脉曲张袜压力。<br>静脉曲张袜分为以下几级压力：<br>一级低压预防保健型(15-25mmHg)：适用于静脉曲张、血栓高发人群的保健预防;一级中压初期治疗型(25-30mmHg)：适用于静脉曲张初期患者;<br>二级高压中度治疗型(30-40mmHg)：适用于下肢已经有明显的静脉曲张(站立时静脉血管凸出皮肤表面)，并伴有腿部不适感的患者(如下肢酸乏肿胀、湿疹瘙痒、抽筋发麻、色素沉着等)、静脉炎、怀孕期间严重静脉曲张、静脉曲张手术后(大小隐静脉剥脱术)患者、深静脉血栓形成后综合症患者;<br>三级高压重度治疗型(40-50mmHg)：适用于下肢高度肿胀、溃疡、皮肤变黑变硬、高度淋巴水肿、整形抽脂术后恢复期等患者。</li><li>根据病变部位选择静脉曲张袜的长度。中统袜(膝下)、长统袜(及大腿)、连裤袜(及腰部)。如果穿者只是膝盖以下的部位患有静脉曲张，穿中统静脉曲张袜即可;如果穿者膝盖以上的部位也有症状、需要穿长统的或者连裤型静脉曲张袜。</li><li>确定合适的号型(静脉曲张袜分为小号S、中号M、大号L、加大号XL)。量出穿者腿部的三个主要尺寸(厘米)：脚踝(脚脖子最细处)周长、小腿肚最大周长及大腿最大周长，以确定合适的号码，购买连裤袜要根据穿者的身高体重选择号码。<blockquote><p><strong>注意</strong>: 如何判断自己的静脉曲张严重程度<br>国际上，静脉曲张按照程度不同共分为0-6期：</p></blockquote></li></ol><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-%E4%B8%A5%E9%87%8D%E7%A8%8B%E5%BA%A6%E5%88%A4%E5%88%AB.jpeg" alt="静脉曲张临床六期图谱表现"></p><p><strong>c1</strong>: 表层血管像蚯蚓一样曲张，明显凸出皮肤，曲张呈团状或结节状，有毛细血管扩张、网状静脉、踝部潮红。<br><strong>c2</strong>: 在站立时腿部可见弯曲增粗的表浅静脉血管，高出皮肤，在腿部抬高或平卧后可消失，常有小腿酸胀、易疲劳等不适感觉，此期是治疗的较好时期。<br><strong>c3</strong>: 曲张血管增多，小腿开始出现水肿，以站立过久或劳累后较明显，晨起时水肿可消退。患肢常比对侧腿增粗，有些人还出现皮肤瘙痒，严重者呈现湿疹、瘀积性皮炎等皮肤病变。<br><strong>c4</strong>: 血管内血液瘀积过多，静脉压力明显增高，使一部分血液成分渗透至血管外的皮肤及皮下组织，造成局部皮肤发红，变紫，直至发黑(血中铁元素沉积)，并且失去弹性而变硬。<br><strong>c5</strong>: 已发展为急性溃疡期，发黑变硬的皮肤在外力作用下发生破溃，采用普通方法已很难康复，严重影响工作与生活。<br><strong>c6</strong>: 静脉曲张晚期，或未经正确治疗的静脉性溃疡反复发作，形成臁疮腿，常见于踝关节附近及小腿下段，俗称“老烂腿”。</p><ol><li>一级压力裤: c1</li><li>二级压力裤: c2-c4</li><li>三级压力裤: c4*c6</li></ol><p><img src="https://github.com/lsy563193/image/raw/master/jmqz-%E9%80%82%E5%90%88%E7%9A%84%E5%8E%8B%E5%8A%9B%E8%A2%9C.png" alt="适合的压力袜子"></p><h4 id="去哪里买"><a href="#去哪里买" class="headerlink" title="去哪里买"></a>去哪里买</h4><ol><li><p>国内压力袜是属于医疗器械，不是哪都可以卖的，如果不是正规的地方卖的，大概率不是真的</p></li><li><p>上外国网站自己买，因为国内压力袜是属于医疗器械，如果有代购或是什麽海淘，如果不是正规的医疗器械卖家，性质像偷卖外国药一样。</p></li></ol><p><a href="https://www.jd.com/phb/1315308f5a70f12facfc.html" target="_blank" rel="noopener">排行版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;静脉曲张形成的主要原因是由于&lt;strong&gt;先天性血管壁膜&lt;/strong&gt;比较薄弱或长时间维持相同姿势很少改变，&lt;strong&gt;血液蓄积下肢&lt;/strong&gt;，在日积月累的情况下&lt;strong&gt;破坏静脉瓣膜&lt;/strong&gt;而产生&lt;strong&gt;静脉压过高&lt;/strong&gt;，使血管突出皮肤表面的症状。&lt;br&gt;
    
    </summary>
    
      <category term="运动康复" scheme="http://lsy563193.github.io/categories/%E8%BF%90%E5%8A%A8%E5%BA%B7%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>封闭阳台</title>
    <link href="http://lsy563193.github.io/homework-Closed-balcony/"/>
    <id>http://lsy563193.github.io/homework-Closed-balcony/</id>
    <published>2018-07-28T14:38:20.000Z</published>
    <updated>2018-11-19T05:28:18.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般封闭阳台由三部分构成</p><ul><li><strong>框窗</strong>:建议安装<code>有框</code> <code>气密窗</code>，最好是经过抗压性、气密性（刮风的时候不会有灰尘钻进来）和水密性（下雨的时候不会有水流到室内）检验的。</li></ul><blockquote><p>注意：　气密性能: 120等级、30等级、8等级、2等级<br>影响因素: 窗户框扇的搭接处、气密防水胶条和毛刷条长度、内扇窗的气密橡胶条与内扇下支长度，毛刷条的完整性，玻璃压条与玻璃长度</p></blockquote><ul><li><strong>玻璃</strong><blockquote><p>钢化玻璃<br>隔音保温表现更好的双层中空玻璃</p></blockquote></li><li><strong>防护栏</strong><a id="more"></a><h2 id="框窗"><a href="#框窗" class="headerlink" title="框窗"></a>框窗</h2></li></ul><p>框窗类型有很多，铝合金门窗、实木窗、铝木复合窗、玻璃钢门窗、不锈钢门窗、无框窗</p><ul><li><strong>塑钢门窗</strong><br>优点是隔音、隔热防火保温，气密性、水密、防腐都不错，而且价格便宜。缺点是它的断面较大，比起铝合金窗来说采光性略差。</li><li><p><strong>铝合金门窗</strong><br>优点: 硬度高，不易刮伤，耐磨耐候，表面光滑，耐污性佳便于清洁。而且价格便宜。<br>缺点: 是导热性强，保温性差。</p></li><li><p><strong>断桥铝合金</strong><br>优点:　结合上面两种<br>缺点:　最贵</p></li></ul><p>-<strong>玻璃门窗（也叫无框窗）</strong><br>优点:采光性良好、空气流通好、美观易折叠等。<br>缺点:保温性差，密封性差，隔音一般。</p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><h3 id="塑钢窗的价格"><a href="#塑钢窗的价格" class="headerlink" title="塑钢窗的价格"></a>塑钢窗的价格</h3><p>塑钢窗主材价格:每种品牌的塑钢窗主材价格不同,如海螺型材现在的价格是10500元/吨,每吨的出窗率要看窗的型号,88推拉窗估计能出95-100平米,80的推拉窗能出100-105平米,60平开窗能出70-75平米左右,按面积计算,也就是88的型材成本价格为110-105元,80的型材成本价格为105-100元,60的型材成本合到150-140元。</p><p>塑钢窗五金配件价格:推拉窗要用到的滑轮和月牙锁,这两个加起来的价格为8元/平米,还有就是密封毛条和减震胶条,加起来价格为10元/平米,再就是制作和安装要30元/平米,另外运输要4元/平米。</p><p>塑钢窗加强钢价格:主材里要有加强钢,市场价格是4000左右/吨,如果用的是1.2的话要成本20元左右,低于这个标准的1.0以下的可能有12元左右就可以了。</p><p>塑钢窗玻璃价格:市场上的玻璃有浮法、格法、平板等几种,浮法的5毫米的玻璃价格30元,格法的24元,平板的19元。如果用中空玻璃的话,除了加一层玻璃的钱还要用到铝合金的框架和干燥外围的中空胶,这些的成本价格是10-15元。</p><p>塑钢窗密封处理价格:主要是打泡沫胶和密封胶,价格要看窗台的平整情况,好的窗台有5元/米就可以,旧的窗台由于拆旧窗的破坏会用到12元/米左右。</p><p>88推拉窗 110 型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=212元/平米。</p><p>80推拉窗 105型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=207元/平米。</p><p>60平开窗 150型材+五38+配件10+制作安装30+20加强钢+玻璃30+运输4=284元/平米。</p><h3 id="铝合金窗的价格"><a href="#铝合金窗的价格" class="headerlink" title="铝合金窗的价格"></a>铝合金窗的价格</h3><p>铝合金普通推拉窗的价格在250元/平方米左右,采用1.2mm厚标准铝型材,单片5mm玻璃;铝合金隔音隔热窗750元/平方米左右,采用1.4厚铝型材,中空玻璃。</p><p>铝合金窗主材价格差别很大,铝材的价格主要差别在铝材的质量上,有厚薄优劣之分,一般氧化铝材160元/平米,电泳铝材200元/平方左右,彩色铝材260元/平米以上。铝型材质有50系列、55系列、60系列、70系列等,其中50系列的铝材价格在400元/平米左右,而70系列铝材价格可达到700元/平米,不同系列的铝材质厚度不一样,铝材越厚的窗户价格越高。</p><p>以上是塑钢窗和铝合金窗的价格介绍,塑钢窗因为用得比较多,大家对它的价格很熟悉。铝合金窗低档的没人愿意用,宁可用塑钢窗代替,高档铝合金窗价格又很高,常用于施工要求较高的建筑或高档建筑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一般封闭阳台由三部分构成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;框窗&lt;/strong&gt;:建议安装&lt;code&gt;有框&lt;/code&gt; &lt;code&gt;气密窗&lt;/code&gt;，最好是经过抗压性、气密性（刮风的时候不会有灰尘钻进来）和水密性（下雨的时候不会有水流到室内）检验的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：　气密性能: 120等级、30等级、8等级、2等级&lt;br&gt;影响因素: 窗户框扇的搭接处、气密防水胶条和毛刷条长度、内扇窗的气密橡胶条与内扇下支长度，毛刷条的完整性，玻璃压条与玻璃长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;玻璃&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;钢化玻璃&lt;br&gt;隔音保温表现更好的双层中空玻璃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防护栏&lt;/strong&gt;
    
    </summary>
    
      <category term="家居收纳" scheme="http://lsy563193.github.io/categories/%E5%AE%B6%E5%B1%85%E6%94%B6%E7%BA%B3/"/>
    
    
      <category term="阳台" scheme="http://lsy563193.github.io/tags/%E9%98%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://lsy563193.github.io/language-python-notes/"/>
    <id>http://lsy563193.github.io/language-python-notes/</id>
    <published>2018-07-26T11:35:47.000Z</published>
    <updated>2018-11-06T04:28:54.531Z</updated>
    
    <content type="html"><![CDATA[<p>python笔记<br>python笔记python笔记<br>python笔记<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python笔记&lt;br&gt;python笔记python笔记&lt;br&gt;python笔记&lt;br&gt;
    
    </summary>
    
      <category term="语言相关" scheme="http://lsy563193.github.io/categories/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="http://lsy563193.github.io/tags/python/"/>
    
  </entry>
  
</feed>
